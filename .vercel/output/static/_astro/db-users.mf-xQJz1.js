import{g as Ar}from"./index.DJO9vBfz.js";class q extends Error{code;rawCode;constructor(e,s,r,n){s!==void 0&&(e=`${s}: ${e}`),super(e,{cause:n}),this.code=s,this.rawCode=r,this.name="LibsqlError"}}function $r(t){const e=Or.exec(t);if(e===null)throw new q(`The URL '${t}' is not in a valid format`,"URL_INVALID");const s=e.groups,r=s.scheme,n=s.authority!==void 0?vr(s.authority):void 0,i=ie(s.path),o=s.query!==void 0?Br(s.query):void 0,a=s.fragment!==void 0?ie(s.fragment):void 0;return{scheme:r,authority:n,path:i,query:o,fragment:a}}const Or=(()=>{const t="(?<scheme>[A-Za-z][A-Za-z.+-]*)",e="(?<authority>[^/?#]*)",s="(?<path>[^?#]*)",r="(?<query>[^#]*)",n="(?<fragment>.*)";return new RegExp(`^${t}:(//${e})?${s}(\\?${r})?(#${n})?$`,"su")})();function vr(t){const e=Qr.exec(t);if(e===null)throw new q("The authority part of the URL is not in a valid format","URL_INVALID");const s=e.groups,r=ie(s.host_br??s.host),n=s.port?parseInt(s.port,10):void 0,i=s.username!==void 0?{username:ie(s.username),password:s.password!==void 0?ie(s.password):void 0}:void 0;return{host:r,port:n,userinfo:i}}const Qr=new RegExp("^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))(:(?<port>[0-9]*))?$","su");function Br(t){const e=t.split("&"),s=[];for(const r of e){if(r==="")continue;let n,i;const o=r.indexOf("=");o<0?(n=r,i=""):(n=r.substring(0,o),i=r.substring(o+1)),s.push({key:ie(n.replaceAll("+"," ")),value:ie(i.replaceAll("+"," "))})}return{pairs:s}}function ie(t){try{return decodeURIComponent(t)}catch(e){throw e instanceof URIError?new q(`URL component has invalid percent encoding: ${e}`,"URL_INVALID",void 0,e):e}}function ft(t,e,s){if(e===void 0)throw new q(`URL with scheme ${JSON.stringify(t+":")} requires authority (the "//" part)`,"URL_INVALID");const r=`${t}:`,n=Pr(e.host),i=Ur(e.port),a=`//${Dr(e.userinfo)}${n}${i}`;let l=s.split("/").map(encodeURIComponent).join("/");return l!==""&&!l.startsWith("/")&&(l="/"+l),new URL(`${r}${a}${l}`)}function Pr(t){return t.includes(":")?`[${encodeURI(t)}]`:encodeURI(t)}function Ur(t){return t!==void 0?`:${t}`:""}function Dr(t){if(t===void 0)return"";const e=encodeURIComponent(t.username),s=t.password!==void 0?`:${encodeURIComponent(t.password)}`:"";return`${e}${s}@`}const Rs="3.7.7",kr=Rs,qe=typeof Buffer=="function",es=typeof TextDecoder=="function"?new TextDecoder:void 0,ts=typeof TextEncoder=="function"?new TextEncoder:void 0,Mr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Ce=Array.prototype.slice.call(Mr),Me=(t=>{let e={};return t.forEach((s,r)=>e[s]=r),e})(Ce),Fr=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,Q=String.fromCharCode.bind(String),ss=typeof Uint8Array.from=="function"?Uint8Array.from.bind(Uint8Array):t=>new Uint8Array(Array.prototype.slice.call(t,0)),Ts=t=>t.replace(/=/g,"").replace(/[+\/]/g,e=>e=="+"?"-":"_"),xs=t=>t.replace(/[^A-Za-z0-9\+\/]/g,""),Ns=t=>{let e,s,r,n,i="";const o=t.length%3;for(let a=0;a<t.length;){if((s=t.charCodeAt(a++))>255||(r=t.charCodeAt(a++))>255||(n=t.charCodeAt(a++))>255)throw new TypeError("invalid character found");e=s<<16|r<<8|n,i+=Ce[e>>18&63]+Ce[e>>12&63]+Ce[e>>6&63]+Ce[e&63]}return o?i.slice(0,o-3)+"===".substring(o):i},Lt=typeof btoa=="function"?t=>btoa(t):qe?t=>Buffer.from(t,"binary").toString("base64"):Ns,pt=qe?t=>Buffer.from(t).toString("base64"):t=>{let s=[];for(let r=0,n=t.length;r<n;r+=4096)s.push(Q.apply(null,t.subarray(r,r+4096)));return Lt(s.join(""))},ze=(t,e=!1)=>e?Ts(pt(t)):pt(t),jr=t=>{if(t.length<2){var e=t.charCodeAt(0);return e<128?t:e<2048?Q(192|e>>>6)+Q(128|e&63):Q(224|e>>>12&15)+Q(128|e>>>6&63)+Q(128|e&63)}else{var e=65536+(t.charCodeAt(0)-55296)*1024+(t.charCodeAt(1)-56320);return Q(240|e>>>18&7)+Q(128|e>>>12&63)+Q(128|e>>>6&63)+Q(128|e&63)}},Vr=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,Cs=t=>t.replace(Vr,jr),rs=qe?t=>Buffer.from(t,"utf8").toString("base64"):ts?t=>pt(ts.encode(t)):t=>Lt(Cs(t)),ye=(t,e=!1)=>e?Ts(rs(t)):rs(t),ns=t=>ye(t,!0),zr=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,Kr=t=>{switch(t.length){case 4:var e=(7&t.charCodeAt(0))<<18|(63&t.charCodeAt(1))<<12|(63&t.charCodeAt(2))<<6|63&t.charCodeAt(3),s=e-65536;return Q((s>>>10)+55296)+Q((s&1023)+56320);case 3:return Q((15&t.charCodeAt(0))<<12|(63&t.charCodeAt(1))<<6|63&t.charCodeAt(2));default:return Q((31&t.charCodeAt(0))<<6|63&t.charCodeAt(1))}},Es=t=>t.replace(zr,Kr),Is=t=>{if(t=t.replace(/\s+/g,""),!Fr.test(t))throw new TypeError("malformed base64.");t+="==".slice(2-(t.length&3));let e,s="",r,n;for(let i=0;i<t.length;)e=Me[t.charAt(i++)]<<18|Me[t.charAt(i++)]<<12|(r=Me[t.charAt(i++)])<<6|(n=Me[t.charAt(i++)]),s+=r===64?Q(e>>16&255):n===64?Q(e>>16&255,e>>8&255):Q(e>>16&255,e>>8&255,e&255);return s},At=typeof atob=="function"?t=>atob(xs(t)):qe?t=>Buffer.from(t,"base64").toString("binary"):Is,Ls=qe?t=>ss(Buffer.from(t,"base64")):t=>ss(At(t).split("").map(e=>e.charCodeAt(0))),As=t=>Ls($s(t)),Wr=qe?t=>Buffer.from(t,"base64").toString("utf8"):es?t=>es.decode(Ls(t)):t=>Es(At(t)),$s=t=>xs(t.replace(/[-_]/g,e=>e=="-"?"+":"/")),mt=t=>Wr($s(t)),Jr=t=>{if(typeof t!="string")return!1;const e=t.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test(e)||!/[^\s0-9a-zA-Z\-_]/.test(e)},Os=t=>({value:t,enumerable:!1,writable:!0,configurable:!0}),vs=function(){const t=(e,s)=>Object.defineProperty(String.prototype,e,Os(s));t("fromBase64",function(){return mt(this)}),t("toBase64",function(e){return ye(this,e)}),t("toBase64URI",function(){return ye(this,!0)}),t("toBase64URL",function(){return ye(this,!0)}),t("toUint8Array",function(){return As(this)})},Qs=function(){const t=(e,s)=>Object.defineProperty(Uint8Array.prototype,e,Os(s));t("toBase64",function(e){return ze(this,e)}),t("toBase64URI",function(){return ze(this,!0)}),t("toBase64URL",function(){return ze(this,!0)})},Hr=()=>{vs(),Qs()},$t={version:Rs,VERSION:kr,atob:At,atobPolyfill:Is,btoa:Lt,btoaPolyfill:Ns,fromBase64:mt,toBase64:ye,encode:ye,encodeURI:ns,encodeURL:ns,utob:Cs,btou:Es,decode:mt,isValid:Jr,fromUint8Array:ze,toUint8Array:As,extendString:vs,extendUint8Array:Qs,extendBuiltins:Hr},Oe="https://github.com/libsql/libsql-client-ts#supported-urls";function yt(t){if(t==="write")return"BEGIN IMMEDIATE";if(t==="read")return"BEGIN TRANSACTION READONLY";if(t==="deferred")return"BEGIN DEFERRED";throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class Gr{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(e,s,r,n,i){this.columns=e,this.columnTypes=s,this.rows=r,this.rowsAffected=n,this.lastInsertRowid=i}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(Xr),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function Xr(t){return Array.prototype.map.call(t,Yr)}function Yr(t){return typeof t=="bigint"?""+t:t instanceof ArrayBuffer?$t.fromUint8Array(new Uint8Array(t)):t}function Zr(t,e){if(typeof t!="object")throw new TypeError(`Expected client configuration as object, got ${typeof t}`);const s=Math.max(0,t.concurrency||20);let r=t.tls,n=t.authToken,i=t.encryptionKey,o=t.syncUrl,a=t.syncInterval;const l=""+(t.intMode??"number");if(l!=="number"&&l!=="bigint"&&l!=="string")throw new TypeError(`Invalid value for intMode, expected "number", "bigint" or "string",             got ${JSON.stringify(l)}`);if(t.url===":memory:")return{path:":memory:",scheme:"file",syncUrl:o,syncInterval:a,intMode:l,fetch:t.fetch,tls:!1,authToken:void 0,encryptionKey:void 0,authority:void 0,concurrency:s};const u=$r(t.url);for(const{key:w,value:S}of u.query?.pairs??[])if(w==="authToken")n=S||void 0;else if(w==="tls")if(S==="0")r=!1;else if(S==="1")r=!0;else throw new q(`Unknown value for the "tls" query argument: ${JSON.stringify(S)}. Supported values are "0" and "1"`,"URL_INVALID");else throw new q(`Unknown URL query parameter ${JSON.stringify(w)}`,"URL_PARAM_NOT_SUPPORTED");const h=u.scheme.toLowerCase();let p;if(h==="libsql")if(r===!1){if(u.authority?.port===void 0)throw new q('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");p="http"}else p="https";else if(h==="http"||h==="ws")p=h,r??=!1;else if(h==="https"||h==="wss"||h==="file")p=h;else throw new q(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(u.scheme+":")}. For more information, please read ${Oe}`,"URL_SCHEME_NOT_SUPPORTED");if(u.fragment!==void 0)throw new q(`URL fragments are not supported: ${JSON.stringify("#"+u.fragment)}`,"URL_INVALID");return{scheme:p,tls:r??!0,authority:u.authority,path:u.path,authToken:n,encryptionKey:i,syncUrl:o,syncInterval:a,intMode:l,fetch:t.fetch,concurrency:s}}let fe;typeof WebSocket<"u"?fe=WebSocket:typeof global<"u"?fe=global.WebSocket:typeof window<"u"?fe=window.WebSocket:typeof self<"u"&&(fe=self.WebSocket);class Bs{constructor(){this.intMode="number"}intMode}class C extends Error{constructor(e){super(e),this.name="ClientError"}}class b extends C{constructor(e){super(e),this.name="ProtoError"}}class Ps extends C{code;proto;constructor(e,s){super(e),this.name="ResponseError",this.code=s.code,this.proto=s,this.stack=void 0}}class W extends C{constructor(e,s){s!==void 0?(super(`${e}: ${s}`),this.cause=s):super(e),this.name="ClosedError"}}class Us extends C{constructor(e){super(e),this.name="WebSocketUnsupportedError"}}class wt extends C{constructor(e){super(e),this.name="WebSocketError"}}class Ds extends C{status;constructor(e,s){super(e),this.status=s,this.name="HttpServerError"}}class be extends C{constructor(e){super(e),this.name="ProtocolVersionError"}}class se extends C{constructor(e){super(e),this.name="InternalError"}}class Re extends C{constructor(e){super(e),this.name="MisuseError"}}function H(t){if(typeof t=="string")return t;throw Te(t,"string")}function G(t){if(t!=null){if(typeof t=="string")return t;throw Te(t,"string or null")}}function oe(t){if(typeof t=="number")return t;throw Te(t,"number")}function ve(t){if(typeof t=="boolean")return t;throw Te(t,"boolean")}function We(t){if(Array.isArray(t))return t;throw Te(t,"array")}function P(t){if(t!==null&&typeof t=="object"&&!Array.isArray(t))return t;throw Te(t,"object")}function re(t,e){return We(t).map(s=>e(P(s)))}function Te(t,e){if(t===void 0)return new b(`Expected ${e}, but the property was missing`);let s=typeof t;return t===null?s="null":Array.isArray(t)&&(s="array"),new b(`Expected ${e}, received ${s}`)}function Ot(t,e){return e(P(t))}class en{#e;#t;constructor(e){this.#e=e,this.#t=!1}begin(){this.#e.push("{"),this.#t=!0}end(){this.#e.push("}"),this.#t=!1}#s(e){this.#t?(this.#e.push('"'),this.#t=!1):this.#e.push(',"'),this.#e.push(e),this.#e.push('":')}string(e,s){this.#s(e),this.#e.push(JSON.stringify(s))}stringRaw(e,s){this.#s(e),this.#e.push('"'),this.#e.push(s),this.#e.push('"')}number(e,s){this.#s(e),this.#e.push(""+s)}boolean(e,s){this.#s(e),this.#e.push(s?"true":"false")}object(e,s,r){this.#s(e),this.begin(),r(this,s),this.end()}arrayObjects(e,s,r){this.#s(e),this.#e.push("[");for(let n=0;n<s.length;++n)n!==0&&this.#e.push(","),this.begin(),r(this,s[n]),this.end();this.#e.push("]")}}function ks(t,e){const s=[],r=new en(s);return r.begin(),e(r,t),r.end(),s.join("")}const Le=0,bt=1,gt=2,tn=5;class sn{#e;#t;#s;constructor(e){this.#e=e,this.#t=new DataView(e.buffer,e.byteOffset,e.byteLength),this.#s=0}varint(){let e=0;for(let s=0;;s+=7){const r=this.#e[this.#s++];if(e|=(r&127)<<s,!(r&128))break}return e}varintBig(){let e=0n;for(let s=0n;;s+=7n){const r=this.#e[this.#s++];if(e|=BigInt(r&127)<<s,!(r&128))break}return e}bytes(e){const s=new Uint8Array(this.#e.buffer,this.#e.byteOffset+this.#s,e);return this.#s+=e,s}double(){const e=this.#t.getFloat64(this.#s,!0);return this.#s+=8,e}skipVarint(){for(;this.#e[this.#s++]&128;);}skip(e){this.#s+=e}eof(){return this.#s>=this.#e.byteLength}}class rn{#e;#t;constructor(e){this.#e=e,this.#t=-1}setup(e){this.#t=e}#s(e){if(this.#t!==e)throw new b(`Expected wire type ${e}, got ${this.#t}`);this.#t=-1}bytes(){this.#s(gt);const e=this.#e.varint();return this.#e.bytes(e)}string(){return new TextDecoder().decode(this.bytes())}message(e){return tt(this.bytes(),e)}int32(){return this.#s(Le),this.#e.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#s(Le),this.#e.varintBig()}sint64(){const e=this.uint64();return e>>1n^-(e&1n)}double(){return this.#s(bt),this.#e.double()}maybeSkip(){if(!(this.#t<0)){if(this.#t===Le)this.#e.skipVarint();else if(this.#t===bt)this.#e.skip(8);else if(this.#t===gt){const e=this.#e.varint();this.#e.skip(e)}else if(this.#t===tn)this.#e.skip(4);else throw new b(`Unexpected wire type ${this.#t}`);this.#t=-1}}}function tt(t,e){const s=new sn(t),r=new rn(s);let n=e.default();for(;!s.eof();){const i=s.varint(),o=i>>3,a=i&7;r.setup(a);const l=e[o];if(l!==void 0){const u=l(r,n);u!==void 0&&(n=u)}r.maybeSkip()}return n}class vt{#e;#t;#s;#r;constructor(){this.#e=new ArrayBuffer(256),this.#t=new Uint8Array(this.#e),this.#s=new DataView(this.#e),this.#r=0}#i(e){if(this.#r+e<=this.#e.byteLength)return;let s=this.#e.byteLength;for(;s<this.#r+e;)s*=2;const r=new ArrayBuffer(s),n=new Uint8Array(r),i=new DataView(r);n.set(new Uint8Array(this.#e,0,this.#r)),this.#e=r,this.#t=n,this.#s=i}#n(e){this.#i(5),e=0|e;do{let s=e&127;e>>>=7,s|=e?128:0,this.#t[this.#r++]=s}while(e)}#a(e){this.#i(10),e=e&0xffffffffffffffffn;do{let s=Number(e&0x7fn);e>>=7n,s|=e?128:0,this.#t[this.#r++]=s}while(e)}#o(e,s){this.#n(e<<3|s)}bytes(e,s){this.#o(e,gt),this.#n(s.byteLength),this.#i(s.byteLength),this.#t.set(s,this.#r),this.#r+=s.byteLength}string(e,s){this.bytes(e,new TextEncoder().encode(s))}message(e,s,r){const n=new vt;r(n,s),this.bytes(e,n.data())}int32(e,s){this.#o(e,Le),this.#n(s)}uint32(e,s){this.int32(e,s)}bool(e,s){this.int32(e,s?1:0)}sint64(e,s){this.#o(e,Le),this.#a(s<<1n^s>>63n)}double(e,s){this.#o(e,bt),this.#i(8),this.#s.setFloat64(this.#r,s,!0),this.#r+=8}data(){return new Uint8Array(this.#e,0,this.#r)}}function Ms(t,e){const s=new vt;return e(s,t),s.data()}class Ee{#e;#t;constructor(){this.#e=new Set,this.#t=new Set}alloc(){for(const s of this.#t)return this.#t.delete(s),this.#e.add(s),this.#e.has(this.#e.size-1)||this.#t.add(this.#e.size-1),s;const e=this.#e.size;return this.#e.add(e),e}free(e){if(!this.#e.delete(e))throw new se("Freeing an id that is not allocated");this.#t.delete(this.#e.size),e<this.#e.size&&this.#t.add(e)}}function E(t,e){throw new se(e)}function Ae(t){if(t===null)return null;if(typeof t=="string")return t;if(typeof t=="number"){if(!Number.isFinite(t))throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return t}else if(typeof t=="bigint"){if(t<nn||t>on)throw new RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return t}else{if(typeof t=="boolean")return t?1n:0n;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(t instanceof Uint8Array)return t;if(t instanceof Date)return+t.valueOf();if(typeof t=="object")return""+t.toString();throw new TypeError("Unsupported type of value")}}const nn=-9223372036854775808n,on=9223372036854775807n;function Fs(t,e){if(t===null)return null;if(typeof t=="number")return t;if(typeof t=="string")return t;if(typeof t=="bigint")if(e==="number"){const s=Number(t);if(!Number.isSafeInteger(s))throw new RangeError("Received integer which is too large to be safely represented as a JavaScript number");return s}else{if(e==="bigint")return t;if(e==="string")return""+t;throw new Re("Invalid value for IntMode")}else{if(t instanceof Uint8Array)return t.slice().buffer;throw t===void 0?new b("Received unrecognized type of Value"):E(t,"Impossible type of Value")}}function Pe(t){return{affectedRowCount:t.affectedRowCount,lastInsertRowid:t.lastInsertRowid,columnNames:t.cols.map(e=>e.name),columnDecltypes:t.cols.map(e=>e.decltype)}}function js(t,e){const s=Pe(t),r=t.rows.map(n=>Ks(s.columnNames,n,e));return{...s,rows:r}}function Vs(t,e){const s=Pe(t);let r;return t.rows.length>0&&(r=Ks(s.columnNames,t.rows[0],e)),{...s,row:r}}function zs(t,e){const s=Pe(t);let r;return t.rows.length>0&&s.columnNames.length>0&&(r=Fs(t.rows[0][0],e)),{...s,value:r}}function Ks(t,e,s){const r={};Object.defineProperty(r,"length",{value:e.length});for(let n=0;n<e.length;++n){const i=Fs(e[n],s);Object.defineProperty(r,n,{value:i});const o=t[n];o!==void 0&&!Object.hasOwn(r,o)&&Object.defineProperty(r,o,{value:i,enumerable:!0,configurable:!0,writable:!0})}return r}function ge(t){return new Ps(t.message,t)}class Qt{#e;#t;#s;constructor(e,s){this.#e=e,this.#t=s,this.#s=void 0}_getSqlId(e){if(this.#e!==e)throw new Re("Attempted to use SQL text opened with other object");if(this.#s!==void 0)throw new W("SQL text is closed",this.#s);return this.#t}close(){this._setClosed(new C("SQL text was manually closed"))}_setClosed(e){this.#s===void 0&&(this.#s=e,this.#e._closeSql(this.#t))}get closed(){return this.#s!==void 0}}function St(t,e){return e instanceof Qt?{sqlId:e._getSqlId(t)}:{sql:""+e}}class Je{#e;#t;constructor(){this.#e=[],this.#t=[]}get length(){return this.#e.length+this.#t.length}push(e){this.#e.push(e)}shift(){return this.#t.length===0&&this.#e.length>0&&(this.#t=this.#e.reverse(),this.#e=[]),this.#t.pop()}first(){return this.#t.length!==0?this.#t[this.#t.length-1]:this.#e[0]}}let _t=class{sql;_args;_namedArgs;constructor(e){this.sql=e,this._args=[],this._namedArgs=new Map}bindIndexes(e){this._args.length=0;for(const s of e)this._args.push(Ae(s));return this}bindIndex(e,s){if(e!==(e|0)||e<=0)throw new RangeError("Index of a positional argument must be positive integer");for(;this._args.length<e;)this._args.push(null);return this._args[e-1]=Ae(s),this}bindName(e,s){return this._namedArgs.set(e,Ae(s)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}};function Ws(t,e,s){let r,n=[],i=[];if(e instanceof _t){r=e.sql,n=e._args;for(const[l,u]of e._namedArgs.entries())i.push({name:l,value:u})}else Array.isArray(e)?(r=e[0],Array.isArray(e[1])?n=e[1].map(l=>Ae(l)):i=Object.entries(e[1]).map(([l,u])=>({name:l,value:Ae(u)}))):r=e;const{sql:o,sqlId:a}=St(t,r);return{sql:o,sqlId:a,args:n,namedArgs:i,wantRows:s}}let an=class{_stream;#e;_steps;#t;constructor(e,s){this._stream=e,this.#e=s,this._steps=[],this.#t=!1}step(){return new cn(this)}execute(){if(this.#t)throw new Re("This batch has already been executed");this.#t=!0;const e={steps:this._steps.map(s=>s.proto)};return this.#e?un(this._stream,this._steps,e):ln(this._stream,this._steps,e)}};function ln(t,e,s){return t._batch(s).then(r=>{for(let n=0;n<e.length;++n){const i=r.stepResults.get(n),o=r.stepErrors.get(n);e[n].callback(i,o)}})}async function un(t,e,s){const r=await t._openCursor(s);try{let n=0,i,o=[];for(;;){const a=await r.next();if(a===void 0)break;if(a.type==="step_begin"){if(a.step<n||a.step>=e.length)throw new b("Server produced StepBeginEntry for unexpected step");if(i!==void 0)throw new b("Server produced StepBeginEntry before terminating previous step");for(let l=n;l<a.step;++l)e[l].callback(void 0,void 0);n=a.step+1,i=a,o=[]}else if(a.type==="step_end"){if(i===void 0)throw new b("Server produced StepEndEntry but no step is active");const l={cols:i.cols,rows:o,affectedRowCount:a.affectedRowCount,lastInsertRowid:a.lastInsertRowid};e[i.step].callback(l,void 0),i=void 0,o=[]}else if(a.type==="step_error"){if(i===void 0){if(a.step>=e.length)throw new b("Server produced StepErrorEntry for unexpected step");for(let l=n;l<a.step;++l)e[l].callback(void 0,void 0)}else{if(a.step!==i.step)throw new b("Server produced StepErrorEntry for unexpected step");i=void 0,o=[]}e[a.step].callback(void 0,a.error),n=a.step+1}else if(a.type==="row"){if(i===void 0)throw new b("Server produced RowEntry but no step is active");o.push(a.row)}else throw a.type==="error"?ge(a.error):a.type==="none"?new b("Server produced unrecognized CursorEntry"):E(a,"Impossible CursorEntry")}if(i!==void 0)throw new b("Server closed Cursor before terminating active step");for(let a=n;a<e.length;++a)e[a].callback(void 0,void 0)}finally{r.close()}}let cn=class{_batch;#e;_index;constructor(e){this._batch=e,this.#e=[],this._index=void 0}condition(e){return this.#e.push(e._proto),this}query(e){return this.#t(e,!0,js)}queryRow(e){return this.#t(e,!0,Vs)}queryValue(e){return this.#t(e,!0,zs)}run(e){return this.#t(e,!1,Pe)}#t(e,s,r){if(this._index!==void 0)throw new Re("This BatchStep has already been added to the batch");const n=Ws(this._batch._stream._sqlOwner(),e,s);let i;this.#e.length===0?i=void 0:this.#e.length===1?i=this.#e[0]:i={type:"and",conds:this.#e.slice()};const o={stmt:n,condition:i};return new Promise((a,l)=>{const u=(h,p)=>{h!==void 0&&p!==void 0?l(new b("Server returned both result and error")):p!==void 0?l(ge(p)):a(h!==void 0?r(h,this._batch._stream.intMode):void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:o,callback:u})})}},D=class ne{_batch;_proto;constructor(e,s){this._batch=e,this._proto=s}static ok(e){return new ne(e._batch,{type:"ok",step:is(e)})}static error(e){return new ne(e._batch,{type:"error",step:is(e)})}static not(e){return new ne(e._batch,{type:"not",cond:e._proto})}static and(e,s){for(const r of s)os(e,r);return new ne(e,{type:"and",conds:s.map(r=>r._proto)})}static or(e,s){for(const r of s)os(e,r);return new ne(e,{type:"or",conds:s.map(r=>r._proto)})}static isAutocommit(e){return e._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new ne(e,{type:"is_autocommit"})}};function is(t){if(t._index===void 0)throw new Re("Cannot add a condition referencing a step that has not been added to the batch");return t._index}function os(t,e){if(e._batch!==t)throw new Re("Cannot mix BatchCond objects for different Batch objects")}function hn(t){return{paramNames:t.params.map(e=>e.name),columns:t.cols,isExplain:t.isExplain,isReadonly:t.isReadonly}}class Js{constructor(e){this.intMode=e}query(e){return this.#e(e,!0,js)}queryRow(e){return this.#e(e,!0,Vs)}queryValue(e){return this.#e(e,!0,zs)}run(e){return this.#e(e,!1,Pe)}#e(e,s,r){const n=Ws(this._sqlOwner(),e,s);return this._execute(n).then(i=>r(i,this.intMode))}batch(e=!1){return new an(this,e)}describe(e){const s=St(this._sqlOwner(),e);return this._describe(s).then(hn)}sequence(e){const s=St(this._sqlOwner(),e);return this._sequence(s)}intMode}class Hs{}const dn=1e3,fn=10;class pn extends Hs{#e;#t;#s;#r;#i;#n;#a;constructor(e,s,r){super(),this.#e=e,this.#t=s,this.#s=r,this.#r=new Je,this.#i=new Je,this.#n=void 0,this.#a=!1}async next(){for(;;){if(this.#n!==void 0)throw new W("Cursor is closed",this.#n);for(;!this.#a&&this.#i.length<fn;)this.#i.push(this.#o());const e=this.#r.shift();if(this.#a||e!==void 0)return e;await this.#i.shift().then(s=>{if(s!==void 0){for(const r of s.entries)this.#r.push(r);this.#a||=s.done}})}}#o(){return this.#t._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#s,maxCount:dn}).then(e=>e,e=>{this._setClosed(e)})}_setClosed(e){this.#n===void 0&&(this.#n=e,this.#t._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#s}).catch(()=>{}),this.#t._cursorClosed(this))}close(){this._setClosed(new C("Cursor was manually closed"))}get closed(){return this.#n!==void 0}}class Bt extends Js{#e;#t;#s;#r;#i;#n;static open(e){const s=e._streamIdAlloc.alloc(),r=new Bt(e,s),n=()=>{},i=a=>r.#u(a),o={type:"open_stream",streamId:s};return e._sendRequest(o,{responseCallback:n,errorCallback:i}),r}constructor(e,s){super(e.intMode),this.#e=e,this.#t=s,this.#s=new Je,this.#r=void 0,this.#i=!1,this.#n=void 0}client(){return this.#e}_sqlOwner(){return this.#e}_execute(e){return this.#a({type:"execute",streamId:this.#t,stmt:e}).then(s=>s.result)}_batch(e){return this.#a({type:"batch",streamId:this.#t,batch:e}).then(s=>s.result)}_describe(e){return this.#e._ensureVersion(2,"describe()"),this.#a({type:"describe",streamId:this.#t,sql:e.sql,sqlId:e.sqlId}).then(s=>s.result)}_sequence(e){return this.#e._ensureVersion(2,"sequence()"),this.#a({type:"sequence",streamId:this.#t,sql:e.sql,sqlId:e.sqlId}).then(s=>{})}getAutocommit(){return this.#e._ensureVersion(3,"getAutocommit()"),this.#a({type:"get_autocommit",streamId:this.#t}).then(e=>e.isAutocommit)}#a(e){return new Promise((s,r)=>{this.#o({type:"request",request:e,responseCallback:s,errorCallback:r})})}_openCursor(e){return this.#e._ensureVersion(3,"cursor"),new Promise((s,r)=>{this.#o({type:"cursor",batch:e,cursorCallback:s,errorCallback:r})})}_sendCursorRequest(e,s){if(e!==this.#r)throw new se("Cursor not associated with the stream attempted to execute a request");return new Promise((r,n)=>{this.#n!==void 0?n(new W("Stream is closed",this.#n)):this.#e._sendRequest(s,{responseCallback:r,errorCallback:n})})}_cursorClosed(e){if(e!==this.#r)throw new se("Cursor was closed, but it was not associated with the stream");this.#r=void 0,this.#l()}#o(e){this.#n!==void 0?e.errorCallback(new W("Stream is closed",this.#n)):this.#i?e.errorCallback(new W("Stream is closing",void 0)):(this.#s.push(e),this.#l())}#l(){for(;;){const e=this.#s.first();if(e===void 0&&this.#r===void 0&&this.#i){this.#u(new C("Stream was gracefully closed"));break}else if(e?.type==="request"&&this.#r===void 0){const{request:s,responseCallback:r,errorCallback:n}=e;this.#s.shift(),this.#e._sendRequest(s,{responseCallback:r,errorCallback:n})}else if(e?.type==="cursor"&&this.#r===void 0){const{batch:s,cursorCallback:r}=e;this.#s.shift();const n=this.#e._cursorIdAlloc.alloc(),i=new pn(this.#e,this,n),o={type:"open_cursor",streamId:this.#t,cursorId:n,batch:s},a=()=>{},l=u=>i._setClosed(u);this.#e._sendRequest(o,{responseCallback:a,errorCallback:l}),this.#r=i,r(i)}else break}}#u(e){if(this.#n!==void 0)return;for(this.#n=e,this.#r!==void 0&&this.#r._setClosed(e);;){const i=this.#s.shift();if(i!==void 0)i.errorCallback(e);else break}const s={type:"close_stream",streamId:this.#t},r=()=>this.#e._streamIdAlloc.free(this.#t),n=()=>{};this.#e._sendRequest(s,{responseCallback:r,errorCallback:n})}close(){this.#u(new C("Stream was manually closed"))}closeGracefully(){this.#i=!0,this.#l()}get closed(){return this.#n!==void 0||this.#i}}function Pt(t,e){e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId),t.arrayObjects("args",e.args,Gs),t.arrayObjects("named_args",e.namedArgs,mn),t.boolean("want_rows",e.wantRows)}function mn(t,e){t.string("name",e.name),t.object("value",e.value,Gs)}function He(t,e){t.arrayObjects("steps",e.steps,yn)}function yn(t,e){e.condition!==void 0&&t.object("condition",e.condition,qt),t.object("stmt",e.stmt,Pt)}function qt(t,e){if(t.stringRaw("type",e.type),e.type==="ok"||e.type==="error")t.number("step",e.step);else if(e.type==="not")t.object("cond",e.cond,qt);else if(e.type==="and"||e.type==="or")t.arrayObjects("conds",e.conds,qt);else if(e.type!=="is_autocommit")throw E(e,"Impossible type of BatchCond")}function Gs(t,e){if(e===null)t.stringRaw("type","null");else if(typeof e=="bigint")t.stringRaw("type","integer"),t.stringRaw("value",""+e);else if(typeof e=="number")t.stringRaw("type","float"),t.number("value",e);else if(typeof e=="string")t.stringRaw("type","text"),t.string("value",e);else if(e instanceof Uint8Array)t.stringRaw("type","blob"),t.stringRaw("base64",$t.fromUint8Array(e));else if(e!==void 0)throw E(e,"Impossible type of Value")}function wn(t,e){if(t.stringRaw("type",e.type),e.type==="hello")e.jwt!==void 0&&t.string("jwt",e.jwt);else if(e.type==="request")t.number("request_id",e.requestId),t.object("request",e.request,bn);else throw E(e,"Impossible type of ClientMsg")}function bn(t,e){if(t.stringRaw("type",e.type),e.type==="open_stream")t.number("stream_id",e.streamId);else if(e.type==="close_stream")t.number("stream_id",e.streamId);else if(e.type==="execute")t.number("stream_id",e.streamId),t.object("stmt",e.stmt,Pt);else if(e.type==="batch")t.number("stream_id",e.streamId),t.object("batch",e.batch,He);else if(e.type==="open_cursor")t.number("stream_id",e.streamId),t.number("cursor_id",e.cursorId),t.object("batch",e.batch,He);else if(e.type==="close_cursor")t.number("cursor_id",e.cursorId);else if(e.type==="fetch_cursor")t.number("cursor_id",e.cursorId),t.number("max_count",e.maxCount);else if(e.type==="sequence")t.number("stream_id",e.streamId),e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="describe")t.number("stream_id",e.streamId),e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="store_sql")t.number("sql_id",e.sqlId),t.string("sql",e.sql);else if(e.type==="close_sql")t.number("sql_id",e.sqlId);else if(e.type==="get_autocommit")t.number("stream_id",e.streamId);else throw E(e,"Impossible type of Request")}function Ut(t,e){e.sql!==void 0&&t.string(1,e.sql),e.sqlId!==void 0&&t.int32(2,e.sqlId);for(const s of e.args)t.message(3,s,Xs);for(const s of e.namedArgs)t.message(4,s,gn);t.bool(5,e.wantRows)}function gn(t,e){t.string(1,e.name),t.message(2,e.value,Xs)}function st(t,e){for(const s of e.steps)t.message(1,s,Sn)}function Sn(t,e){e.condition!==void 0&&t.message(1,e.condition,Dt),t.message(2,e.stmt,Ut)}function Dt(t,e){if(e.type==="ok")t.uint32(1,e.step);else if(e.type==="error")t.uint32(2,e.step);else if(e.type==="not")t.message(3,e.cond,Dt);else if(e.type==="and")t.message(4,e.conds,as);else if(e.type==="or")t.message(5,e.conds,as);else if(e.type==="is_autocommit")t.message(6,void 0,Ys);else throw E(e,"Impossible type of BatchCond")}function as(t,e){for(const s of e)t.message(1,s,Dt)}function Xs(t,e){if(e===null)t.message(1,void 0,Ys);else if(typeof e=="bigint")t.sint64(2,e);else if(typeof e=="number")t.double(3,e);else if(typeof e=="string")t.string(4,e);else if(e instanceof Uint8Array)t.bytes(5,e);else if(e!==void 0)throw E(e,"Impossible type of Value")}function Ys(t,e){}function _n(t,e){if(e.type==="hello")t.message(1,e,qn);else if(e.type==="request")t.message(2,e,Rn);else throw E(e,"Impossible type of ClientMsg")}function qn(t,e){e.jwt!==void 0&&t.string(1,e.jwt)}function Rn(t,e){t.int32(1,e.requestId);const s=e.request;if(s.type==="open_stream")t.message(2,s,Tn);else if(s.type==="close_stream")t.message(3,s,xn);else if(s.type==="execute")t.message(4,s,Nn);else if(s.type==="batch")t.message(5,s,Cn);else if(s.type==="open_cursor")t.message(6,s,En);else if(s.type==="close_cursor")t.message(7,s,In);else if(s.type==="fetch_cursor")t.message(8,s,Ln);else if(s.type==="sequence")t.message(9,s,An);else if(s.type==="describe")t.message(10,s,$n);else if(s.type==="store_sql")t.message(11,s,On);else if(s.type==="close_sql")t.message(12,s,vn);else if(s.type==="get_autocommit")t.message(13,s,Qn);else throw E(s,"Impossible type of Request")}function Tn(t,e){t.int32(1,e.streamId)}function xn(t,e){t.int32(1,e.streamId)}function Nn(t,e){t.int32(1,e.streamId),t.message(2,e.stmt,Ut)}function Cn(t,e){t.int32(1,e.streamId),t.message(2,e.batch,st)}function En(t,e){t.int32(1,e.streamId),t.int32(2,e.cursorId),t.message(3,e.batch,st)}function In(t,e){t.int32(1,e.cursorId)}function Ln(t,e){t.int32(1,e.cursorId),t.uint32(2,e.maxCount)}function An(t,e){t.int32(1,e.streamId),e.sql!==void 0&&t.string(2,e.sql),e.sqlId!==void 0&&t.int32(3,e.sqlId)}function $n(t,e){t.int32(1,e.streamId),e.sql!==void 0&&t.string(2,e.sql),e.sqlId!==void 0&&t.int32(3,e.sqlId)}function On(t,e){t.int32(1,e.sqlId),t.string(2,e.sql)}function vn(t,e){t.int32(1,e.sqlId)}function Qn(t,e){t.int32(1,e.streamId)}function Se(t){const e=H(t.message),s=G(t.code);return{message:e,code:s}}function kt(t){const e=re(t.cols,Zs),s=We(t.rows).map(o=>re(o,rr)),r=oe(t.affected_row_count),n=G(t.last_insert_rowid),i=n!==void 0?BigInt(n):void 0;return{cols:e,rows:s,affectedRowCount:r,lastInsertRowid:i}}function Zs(t){const e=G(t.name),s=G(t.decltype);return{name:e,decltype:s}}function er(t){const e=new Map;We(t.step_results).forEach((r,n)=>{r!==null&&e.set(n,kt(P(r)))});const s=new Map;return We(t.step_errors).forEach((r,n)=>{r!==null&&s.set(n,Se(P(r)))}),{stepResults:e,stepErrors:s}}function tr(t){const e=H(t.type);if(e==="step_begin"){const s=oe(t.step),r=re(t.cols,Zs);return{type:"step_begin",step:s,cols:r}}else if(e==="step_end"){const s=oe(t.affected_row_count),r=G(t.last_insert_rowid),n=r!==void 0?BigInt(r):void 0;return{type:"step_end",affectedRowCount:s,lastInsertRowid:n}}else if(e==="step_error"){const s=oe(t.step),r=Se(P(t.error));return{type:"step_error",step:s,error:r}}else{if(e==="row")return{type:"row",row:re(t.row,rr)};if(e==="error")return{type:"error",error:Se(P(t.error))};throw new b("Unexpected type of CursorEntry")}}function sr(t){const e=re(t.params,Bn),s=re(t.cols,Pn),r=ve(t.is_explain),n=ve(t.is_readonly);return{params:e,cols:s,isExplain:r,isReadonly:n}}function Bn(t){return{name:G(t.name)}}function Pn(t){const e=H(t.name),s=G(t.decltype);return{name:e,decltype:s}}function rr(t){const e=H(t.type);if(e==="null")return null;if(e==="integer"){const s=H(t.value);return BigInt(s)}else{if(e==="float")return oe(t.value);if(e==="text")return H(t.value);if(e==="blob")return $t.toUint8Array(H(t.base64));throw new b("Unexpected type of Value")}}function Un(t){const e=H(t.type);if(e==="hello_ok")return{type:"hello_ok"};if(e==="hello_error")return{type:"hello_error",error:Se(P(t.error))};if(e==="response_ok"){const s=oe(t.request_id),r=Dn(P(t.response));return{type:"response_ok",requestId:s,response:r}}else if(e==="response_error"){const s=oe(t.request_id),r=Se(P(t.error));return{type:"response_error",requestId:s,error:r}}else throw new b("Unexpected type of ServerMsg")}function Dn(t){const e=H(t.type);if(e==="open_stream")return{type:"open_stream"};if(e==="close_stream")return{type:"close_stream"};if(e==="execute")return{type:"execute",result:kt(P(t.result))};if(e==="batch")return{type:"batch",result:er(P(t.result))};if(e==="open_cursor")return{type:"open_cursor"};if(e==="close_cursor")return{type:"close_cursor"};if(e==="fetch_cursor"){const s=re(t.entries,tr),r=ve(t.done);return{type:"fetch_cursor",entries:s,done:r}}else{if(e==="sequence")return{type:"sequence"};if(e==="describe")return{type:"describe",result:sr(P(t.result))};if(e==="store_sql")return{type:"store_sql"};if(e==="close_sql")return{type:"close_sql"};if(e==="get_autocommit")return{type:"get_autocommit",isAutocommit:ve(t.is_autocommit)};throw new b("Unexpected type of Response")}}const X={default(){return{message:"",code:void 0}},1(t,e){e.message=t.string()},2(t,e){e.code=t.string()}},_e={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(t,e){e.cols.push(t.message(nr))},2(t,e){e.rows.push(t.message(ir))},3(t,e){e.affectedRowCount=Number(t.uint64())},4(t,e){e.lastInsertRowid=t.sint64()}},nr={default(){return{name:void 0,decltype:void 0}},1(t,e){e.name=t.string()},2(t,e){e.decltype=t.string()}},ir={default(){return[]},1(t,e){e.push(t.message(Wn))}},Ge={default(){return{stepResults:new Map,stepErrors:new Map}},1(t,e){const[s,r]=t.message(kn);e.stepResults.set(s,r)},2(t,e){const[s,r]=t.message(Mn);e.stepErrors.set(s,r)}},kn={default(){return[0,_e.default()]},1(t,e){e[0]=t.uint32()},2(t,e){e[1]=t.message(_e)}},Mn={default(){return[0,X.default()]},1(t,e){e[0]=t.uint32()},2(t,e){e[1]=t.message(X)}},or={default(){return{type:"none"}},1(t){return t.message(Fn)},2(t){return t.message(jn)},3(t){return t.message(Vn)},4(t){return{type:"row",row:t.message(ir)}},5(t){return{type:"error",error:t.message(X)}}},Fn={default(){return{type:"step_begin",step:0,cols:[]}},1(t,e){e.step=t.uint32()},2(t,e){e.cols.push(t.message(nr))}},jn={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(t,e){e.affectedRowCount=t.uint32()},2(t,e){e.lastInsertRowid=t.uint64()}},Vn={default(){return{type:"step_error",step:0,error:X.default()}},1(t,e){e.step=t.uint32()},2(t,e){e.error=t.message(X)}},Xe={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(t,e){e.params.push(t.message(zn))},2(t,e){e.cols.push(t.message(Kn))},3(t,e){e.isExplain=t.bool()},4(t,e){e.isReadonly=t.bool()}},zn={default(){return{name:void 0}},1(t,e){e.name=t.string()}},Kn={default(){return{name:"",decltype:void 0}},1(t,e){e.name=t.string()},2(t,e){e.decltype=t.string()}},Wn={default(){},1(t){return null},2(t){return t.sint64()},3(t){return t.double()},4(t){return t.string()},5(t){return t.bytes()}},Jn={default(){return{type:"none"}},1(t){return{type:"hello_ok"}},2(t){return t.message(Hn)},3(t){return t.message(Xn)},4(t){return t.message(Gn)}},Hn={default(){return{type:"hello_error",error:X.default()}},1(t,e){e.error=t.message(X)}},Gn={default(){return{type:"response_error",requestId:0,error:X.default()}},1(t,e){e.requestId=t.int32()},2(t,e){e.error=t.message(X)}},Xn={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(t,e){e.requestId=t.int32()},2(t,e){e.response={type:"open_stream"}},3(t,e){e.response={type:"close_stream"}},4(t,e){e.response=t.message(Yn)},5(t,e){e.response=t.message(Zn)},6(t,e){e.response={type:"open_cursor"}},7(t,e){e.response={type:"close_cursor"}},8(t,e){e.response=t.message(ei)},9(t,e){e.response={type:"sequence"}},10(t,e){e.response=t.message(ti)},11(t,e){e.response={type:"store_sql"}},12(t,e){e.response={type:"close_sql"}},13(t,e){e.response=t.message(si)}},Yn={default(){return{type:"execute",result:_e.default()}},1(t,e){e.result=t.message(_e)}},Zn={default(){return{type:"batch",result:Ge.default()}},1(t,e){e.result=t.message(Ge)}},ei={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(t,e){e.entries.push(t.message(or))},2(t,e){e.done=t.bool()}},ti={default(){return{type:"describe",result:Xe.default()}},1(t,e){e.result=t.message(Xe)}},si={default(){return{type:"get_autocommit",isAutocommit:!1}},1(t,e){e.isAutocommit=t.bool()}},ri=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),ar=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);let ni=class extends Bs{#e;#t;#s;#r;#i;#n;#a;#o;#l;_streamIdAlloc;_cursorIdAlloc;#u;constructor(e,s){super(),this.#e=e,this.#t=[],this.#s=!1,this.#r=void 0,this.#i=!1,this.#n=void 0,this.#a=!1,this.#o=new Map,this.#l=new Ee,this._streamIdAlloc=new Ee,this._cursorIdAlloc=new Ee,this.#u=new Ee,this.#e.binaryType="arraybuffer",this.#e.addEventListener("open",()=>this.#p()),this.#e.addEventListener("close",r=>this.#f(r)),this.#e.addEventListener("error",r=>this.#m(r)),this.#e.addEventListener("message",r=>this.#w(r)),this.#h({type:"hello",jwt:s})}#h(e){if(this.#r!==void 0)throw new se("Trying to send a message on a closed client");if(this.#s)this.#d(e);else{const s=()=>this.#d(e),r=()=>{};this.#t.push({openCallback:s,errorCallback:r})}}#p(){const e=this.#e.protocol;if(e===void 0){this.#c(new C("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(e==="")this.#n={version:1,encoding:"json"};else if(this.#n=ar.get(e),this.#n===void 0){this.#c(new b(`Unrecognized WebSocket subprotocol: ${JSON.stringify(e)}`));return}for(const s of this.#t)s.openCallback();this.#t.length=0,this.#s=!0}#d(e){const s=this.#n.encoding;if(s==="json"){const r=ks(e,wn);this.#e.send(r)}else if(s==="protobuf"){const r=Ms(e,_n);this.#e.send(r)}else throw E(s,"Impossible encoding")}getVersion(){return new Promise((e,s)=>{if(this.#a=!0,this.#r!==void 0)s(this.#r);else if(this.#s)e(this.#n.version);else{const r=()=>e(this.#n.version);this.#t.push({openCallback:r,errorCallback:s})}})}_ensureVersion(e,s){if(this.#n===void 0||!this.#a)throw new be(`${s} is supported only on protocol version ${e} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);if(this.#n.version<e)throw new be(`${s} is supported on protocol version ${e} and higher, but the WebSocket server only supports version ${this.#n.version}`)}_sendRequest(e,s){if(this.#r!==void 0){s.errorCallback(new W("Client is closed",this.#r));return}const r=this.#l.alloc();this.#o.set(r,{...s,type:e.type}),this.#h({type:"request",requestId:r,request:e})}#m(e){const r=e.message??"WebSocket was closed due to an error";this.#c(new wt(r))}#f(e){let s=`WebSocket was closed with code ${e.code}`;e.reason&&(s+=`: ${e.reason}`),this.#c(new wt(s))}#c(e){if(this.#r===void 0){this.#r=e;for(const s of this.#t)s.errorCallback(e);this.#t.length=0;for(const[s,r]of this.#o.entries())r.errorCallback(e),this.#l.free(s);this.#o.clear(),this.#e.close()}}#w(e){if(this.#r===void 0)try{let s;const r=this.#n.encoding;if(r==="json"){if(typeof e.data!="string"){this.#e.close(3003,"Only text messages are accepted with JSON encoding"),this.#c(new b("Received non-text message from server with JSON encoding"));return}s=Ot(JSON.parse(e.data),Un)}else if(r==="protobuf"){if(!(e.data instanceof ArrayBuffer)){this.#e.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#c(new b("Received non-binary message from server with Protobuf encoding"));return}s=tt(new Uint8Array(e.data),Jn)}else throw E(r,"Impossible encoding");this.#y(s)}catch(s){this.#e.close(3007,"Could not handle message"),this.#c(s)}}#y(e){if(e.type==="none")throw new b("Received an unrecognized ServerMsg");if(e.type==="hello_ok"||e.type==="hello_error"){if(this.#i)throw new b("Received a duplicated hello response");if(this.#i=!0,e.type==="hello_error")throw ge(e.error);return}else if(!this.#i)throw new b("Received a non-hello message before a hello response");if(e.type==="response_ok"){const s=e.requestId,r=this.#o.get(s);if(this.#o.delete(s),r===void 0)throw new b("Received unexpected OK response");this.#l.free(s);try{if(r.type!==e.response.type)throw console.dir({responseState:r,msg:e}),new b("Received unexpected type of response");r.responseCallback(e.response)}catch(n){throw r.errorCallback(n),n}}else if(e.type==="response_error"){const s=e.requestId,r=this.#o.get(s);if(this.#o.delete(s),r===void 0)throw new b("Received unexpected error response");this.#l.free(s),r.errorCallback(ge(e.error))}else throw E(e,"Impossible ServerMsg type")}openStream(){return Bt.open(this)}storeSql(e){this._ensureVersion(2,"storeSql()");const s=this.#u.alloc(),r=new Qt(this,s),n=()=>{},i=a=>r._setClosed(a),o={type:"store_sql",sqlId:s,sql:e};return this._sendRequest(o,{responseCallback:n,errorCallback:i}),r}_closeSql(e){if(this.#r!==void 0)return;const s=()=>this.#u.free(e),r=i=>this.#c(i),n={type:"close_sql",sqlId:e};this._sendRequest(n,{responseCallback:s,errorCallback:r})}close(){this.#c(new C("Client was manually closed"))}get closed(){return this.#r!==void 0}};const ii=fetch,lr=Request,oi=Headers;let pe;if(typeof queueMicrotask<"u")pe=queueMicrotask;else{const t=Promise.resolve();pe=e=>{t.then(e)}}class ai{#e;#t;#s;constructor(e){this.#e=new Uint8Array(new ArrayBuffer(e)),this.#t=0,this.#s=0}get length(){return this.#s-this.#t}data(){return this.#e.slice(this.#t,this.#s)}push(e){this.#r(e.byteLength),this.#e.set(e,this.#s),this.#s+=e.byteLength}#r(e){if(this.#s+e<=this.#e.byteLength)return;const s=this.#s-this.#t;if(s+e<=this.#e.byteLength&&2*this.#s>=this.#e.byteLength)this.#e.copyWithin(0,this.#t,this.#s);else{let r=this.#e.byteLength;do r*=2;while(s+e>r);const n=new Uint8Array(new ArrayBuffer(r));n.set(this.#e.slice(this.#t,this.#s),0),this.#e=n}this.#s=s,this.#t=0}shift(e){this.#t+=e}}function li(t){const e=G(t.baton),s=G(t.base_url),r=re(t.results,ui);return{baton:e,baseUrl:s,results:r}}function ui(t){const e=H(t.type);if(e==="ok")return{type:"ok",response:ci(P(t.response))};if(e==="error")return{type:"error",error:Se(P(t.error))};throw new b("Unexpected type of StreamResult")}function ci(t){const e=H(t.type);if(e==="close")return{type:"close"};if(e==="execute")return{type:"execute",result:kt(P(t.result))};if(e==="batch")return{type:"batch",result:er(P(t.result))};if(e==="sequence")return{type:"sequence"};if(e==="describe")return{type:"describe",result:sr(P(t.result))};if(e==="store_sql")return{type:"store_sql"};if(e==="close_sql")return{type:"close_sql"};if(e==="get_autocommit")return{type:"get_autocommit",isAutocommit:ve(t.is_autocommit)};throw new b("Unexpected type of StreamResponse")}function hi(t){const e=G(t.baton),s=G(t.base_url);return{baton:e,baseUrl:s}}const di={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(t,e){e.baton=t.string()},2(t,e){e.baseUrl=t.string()},3(t,e){e.results.push(t.message(fi))}},fi={default(){return{type:"none"}},1(t){return{type:"ok",response:t.message(pi)}},2(t){return{type:"error",error:t.message(X)}}},pi={default(){return{type:"none"}},1(t){return{type:"close"}},2(t){return t.message(mi)},3(t){return t.message(yi)},4(t){return{type:"sequence"}},5(t){return t.message(wi)},6(t){return{type:"store_sql"}},7(t){return{type:"close_sql"}},8(t){return t.message(bi)}},mi={default(){return{type:"execute",result:_e.default()}},1(t,e){e.result=t.message(_e)}},yi={default(){return{type:"batch",result:Ge.default()}},1(t,e){e.result=t.message(Ge)}},wi={default(){return{type:"describe",result:Xe.default()}},1(t,e){e.result=t.message(Xe)}},bi={default(){return{type:"get_autocommit",isAutocommit:!1}},1(t,e){e.isAutocommit=t.bool()}},gi={default(){return{baton:void 0,baseUrl:void 0}},1(t,e){e.baton=t.string()},2(t,e){e.baseUrl=t.string()}};class Si extends Hs{#e;#t;#s;#r;#i;#n;constructor(e,s){super(),this.#e=e,this.#t=s,this.#s=void 0,this.#r=new ai(16*1024),this.#i=void 0,this.#n=!1}async open(e){if(e.body===null)throw new b("No response body for cursor request");this.#s=e.body.getReader();const s=await this.#a(hi,gi);if(s===void 0)throw new b("Empty response to cursor request");return s}next(){return this.#a(tr,or)}close(){this._setClosed(new C("Cursor was manually closed"))}_setClosed(e){this.#i===void 0&&(this.#i=e,this.#e._cursorClosed(this),this.#s!==void 0&&this.#s.cancel())}get closed(){return this.#i!==void 0}async#a(e,s){for(;;){if(this.#n)return;if(this.#i!==void 0)throw new W("Cursor is closed",this.#i);if(this.#t==="json"){const i=this.#o();if(i!==void 0){const o=new TextDecoder().decode(i),a=JSON.parse(o);return Ot(a,e)}}else if(this.#t==="protobuf"){const i=this.#l();if(i!==void 0)return tt(i,s)}else throw E(this.#t,"Impossible encoding");if(this.#s===void 0)throw new se("Attempted to read from HTTP cursor before it was opened");const{value:r,done:n}=await this.#s.read();if(n&&this.#r.length===0)this.#n=!0;else{if(n)throw new b("Unexpected end of cursor stream");this.#r.push(r)}}}#o(){const e=this.#r.data(),r=e.indexOf(10);if(r<0)return;const n=e.slice(0,r);return this.#r.shift(r+1),n}#l(){const e=this.#r.data();let s=0,r=0;for(;;){if(r>=e.byteLength)return;const i=e[r];if(s|=(i&127)<<7*r,r+=1,!(i&128))break}if(e.byteLength<r+s)return;const n=e.slice(r,r+s);return this.#r.shift(r+s),n}}function _i(t,e){e.baton!==void 0&&t.string("baton",e.baton),t.arrayObjects("requests",e.requests,qi)}function qi(t,e){if(t.stringRaw("type",e.type),e.type!=="close"){if(e.type==="execute")t.object("stmt",e.stmt,Pt);else if(e.type==="batch")t.object("batch",e.batch,He);else if(e.type==="sequence")e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="describe")e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="store_sql")t.number("sql_id",e.sqlId),t.string("sql",e.sql);else if(e.type==="close_sql")t.number("sql_id",e.sqlId);else if(e.type!=="get_autocommit")throw E(e,"Impossible type of StreamRequest")}}function Ri(t,e){e.baton!==void 0&&t.string("baton",e.baton),t.object("batch",e.batch,He)}function Ti(t,e){e.baton!==void 0&&t.string(1,e.baton);for(const s of e.requests)t.message(2,s,xi)}function xi(t,e){if(e.type==="close")t.message(1,e,Ni);else if(e.type==="execute")t.message(2,e,Ci);else if(e.type==="batch")t.message(3,e,Ei);else if(e.type==="sequence")t.message(4,e,Ii);else if(e.type==="describe")t.message(5,e,Li);else if(e.type==="store_sql")t.message(6,e,Ai);else if(e.type==="close_sql")t.message(7,e,$i);else if(e.type==="get_autocommit")t.message(8,e,Oi);else throw E(e,"Impossible type of StreamRequest")}function Ni(t,e){}function Ci(t,e){t.message(1,e.stmt,Ut)}function Ei(t,e){t.message(1,e.batch,st)}function Ii(t,e){e.sql!==void 0&&t.string(1,e.sql),e.sqlId!==void 0&&t.int32(2,e.sqlId)}function Li(t,e){e.sql!==void 0&&t.string(1,e.sql),e.sqlId!==void 0&&t.int32(2,e.sqlId)}function Ai(t,e){t.int32(1,e.sqlId),t.string(2,e.sql)}function $i(t,e){t.int32(1,e.sqlId)}function Oi(t,e){}function vi(t,e){e.baton!==void 0&&t.string(1,e.baton),t.message(2,e.batch,st)}class Qi extends Js{#e;#t;#s;#r;#i;#n;#a;#o;#l;#u;#h;#p;constructor(e,s,r,n){super(e.intMode),this.#e=e,this.#t=s.toString(),this.#s=r,this.#r=n,this.#i=void 0,this.#n=new Je,this.#a=!1,this.#l=!1,this.#u=!1,this.#h=void 0,this.#p=new Ee}client(){return this.#e}_sqlOwner(){return this}storeSql(e){const s=this.#p.alloc();return this.#d({type:"store_sql",sqlId:s,sql:e}).then(()=>{},r=>this._setClosed(r)),new Qt(this,s)}_closeSql(e){this.#h===void 0&&this.#d({type:"close_sql",sqlId:e}).then(()=>this.#p.free(e),s=>this._setClosed(s))}_execute(e){return this.#d({type:"execute",stmt:e}).then(s=>s.result)}_batch(e){return this.#d({type:"batch",batch:e}).then(s=>s.result)}_describe(e){return this.#d({type:"describe",sql:e.sql,sqlId:e.sqlId}).then(s=>s.result)}_sequence(e){return this.#d({type:"sequence",sql:e.sql,sqlId:e.sqlId}).then(s=>{})}getAutocommit(){return this.#e._ensureVersion(3,"getAutocommit()"),this.#d({type:"get_autocommit"}).then(e=>e.isAutocommit)}#d(e){return new Promise((s,r)=>{this.#m({type:"pipeline",request:e,responseCallback:s,errorCallback:r})})}_openCursor(e){return new Promise((s,r)=>{this.#m({type:"cursor",batch:e,cursorCallback:s,errorCallback:r})})}_cursorClosed(e){if(e!==this.#o)throw new se("Cursor was closed, but it was not associated with the stream");this.#o=void 0,pe(()=>this.#f())}close(){this._setClosed(new C("Stream was manually closed"))}closeGracefully(){this.#l=!0,pe(()=>this.#f())}get closed(){return this.#h!==void 0||this.#l}_setClosed(e){if(this.#h===void 0){for(this.#h=e,this.#o!==void 0&&this.#o._setClosed(e),this.#e._streamClosed(this);;){const s=this.#n.shift();if(s!==void 0)s.errorCallback(e);else break}(this.#i!==void 0||this.#a)&&!this.#u&&(this.#n.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{},errorCallback:()=>{}}),this.#u=!0,pe(()=>this.#f()))}}#m(e){if(this.#h!==void 0)throw new W("Stream is closed",this.#h);if(this.#l)throw new W("Stream is closing",void 0);this.#n.push(e),pe(()=>this.#f())}#f(){if(this.#a||this.#o!==void 0)return;if(this.#l&&this.#n.length===0){this._setClosed(new C("Stream was gracefully closed"));return}const e=this.#e._endpoint;if(e===void 0){this.#e._endpointPromise.then(()=>this.#f(),r=>this._setClosed(r));return}const s=this.#n.shift();if(s!==void 0)if(s.type==="pipeline"){const r=[s];for(;;){const n=this.#n.first();if(n!==void 0&&n.type==="pipeline")r.push(n),this.#n.shift();else if(n===void 0&&this.#l&&!this.#u){r.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{},errorCallback:()=>{}}),this.#u=!0;break}else break}this.#c(e,r)}else if(s.type==="cursor")this.#w(e,s);else throw E(s,"Impossible type of QueueEntry")}#c(e,s){this.#y(()=>this.#g(s,e),r=>Pi(r,e.encoding),r=>r.baton,r=>r.baseUrl,r=>Bi(s,r),r=>s.forEach(n=>n.errorCallback(r)))}#w(e,s){const r=new Si(this,e.encoding);this.#o=r,this.#y(()=>this.#S(s,e),n=>r.open(n),n=>n.baton,n=>n.baseUrl,n=>s.cursorCallback(r),n=>s.errorCallback(n))}#y(e,s,r,n,i,o){let a;try{const l=e(),u=this.#r;a=u(l)}catch(l){a=Promise.reject(l)}this.#a=!0,a.then(l=>l.ok?s(l):Ui(l).then(u=>{throw u})).then(l=>{this.#i=r(l),this.#t=n(l)??this.#t,i(l)}).catch(l=>{this._setClosed(l),o(l)}).finally(()=>{this.#a=!1,this.#f()})}#g(e,s){return this.#b(new URL(s.pipelinePath,this.#t),{baton:this.#i,requests:e.map(r=>r.request)},s.encoding,_i,Ti)}#S(e,s){if(s.cursorPath===void 0)throw new be(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${s.version}.`);return this.#b(new URL(s.cursorPath,this.#t),{baton:this.#i,batch:e.batch},s.encoding,Ri,vi)}#b(e,s,r,n,i){let o,a;if(r==="json")o=ks(s,n),a="application/json";else if(r==="protobuf")o=Ms(s,i),a="application/x-protobuf";else throw E(r,"Impossible encoding");const l=new oi;return l.set("content-type",a),this.#s!==void 0&&l.set("authorization",`Bearer ${this.#s}`),new lr(e.toString(),{method:"POST",headers:l,body:o})}}function Bi(t,e){if(e.results.length!==t.length)throw new b("Server returned unexpected number of pipeline results");for(let s=0;s<t.length;++s){const r=e.results[s],n=t[s];if(r.type==="ok"){if(r.response.type!==n.request.type)throw new b("Received unexpected type of response");n.responseCallback(r.response)}else if(r.type==="error")n.errorCallback(ge(r.error));else throw r.type==="none"?new b("Received unrecognized type of StreamResult"):E(r,"Received impossible type of StreamResult")}}async function Pi(t,e){if(e==="json"){const s=await t.json();return Ot(s,li)}else if(e==="protobuf"){const s=await t.arrayBuffer();return tt(new Uint8Array(s),di)}else throw E(e,"Impossible encoding")}async function Ui(t){const e=t.headers.get("content-type")??"text/plain";if(e==="application/json"){const r=await t.json();if("message"in r)return ge(r)}let s=`Server returned HTTP status ${t.status}`;if(e==="text/plain"){const r=(await t.text()).trim();r!==""&&(s+=`: ${r}`)}return new Ds(s,t.status)}const Di=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],Rt={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};let ki=class extends Bs{#e;#t;#s;#r;#i;_endpointPromise;_endpoint;constructor(e,s,r,n=2){super(),this.#e=e,this.#t=s,this.#s=r??ii,this.#r=void 0,this.#i=new Set,n==3?(this._endpointPromise=Mi(this.#s,this.#e),this._endpointPromise.then(i=>this._endpoint=i,i=>this.#n(i))):(this._endpointPromise=Promise.resolve(Rt),this._endpointPromise.then(i=>this._endpoint=i,i=>this.#n(i)))}async getVersion(){return this._endpoint!==void 0?this._endpoint.version:(await this._endpointPromise).version}_ensureVersion(e,s){if(!(e<=Rt.version)){if(this._endpoint===void 0)throw new be(`${s} is supported only on protocol version ${e} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);if(this._endpoint.version<e)throw new be(`${s} is supported only on protocol version ${e} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}}openStream(){if(this.#r!==void 0)throw new W("Client is closed",this.#r);const e=new Qi(this,this.#e,this.#t,this.#s);return this.#i.add(e),e}_streamClosed(e){this.#i.delete(e)}close(){this.#n(new C("Client was manually closed"))}get closed(){return this.#r!==void 0}#n(e){if(this.#r===void 0){this.#r=e;for(const s of Array.from(this.#i))s._setClosed(new W("Client was closed",e))}}};async function Mi(t,e){const s=t;for(const r of Di){const n=new URL(r.versionPath,e),i=new lr(n.toString(),{method:"GET"}),o=await s(i);if(await o.arrayBuffer(),o.ok)return r}return Rt}function ur(t,e,s=2){if(typeof fe>"u")throw new Us("WebSockets are not supported in this environment");var r=void 0;s==3?r=Array.from(ar.keys()):r=Array.from(ri.keys());const n=new fe(t,r);return new ni(n,e)}function Fi(t,e,s,r=2){return new ki(t instanceof URL?t:new URL(t),e,s,r)}class cr{#e;#t;#s;constructor(e,s){this.#e=e,this.#t=s,this.#s=void 0}execute(e){return this.batch([e]).then(s=>s[0])}async batch(e){const s=this._getStream();if(s.closed)throw new q("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{const r=e.map(Qe);let n;if(this.#s===void 0){this._getSqlCache().apply(r);const o=s.batch(this.#t>=3),a=o.step(),l=a.run(yt(this.#e));let u=a;n=r.map(h=>{const p=o.step().condition(D.ok(u));this.#t>=3&&p.condition(D.not(D.isAutocommit(o)));const w=p.query(h);return w.catch(()=>{}),u=p,w}),this.#s=o.execute().then(()=>l).then(()=>{});try{await this.#s}catch(h){throw this.close(),h}}else{this.#t<3&&await this.#s,this._getSqlCache().apply(r);const o=s.batch(this.#t>=3);let a;n=r.map(l=>{const u=o.step();a!==void 0&&u.condition(D.ok(a)),this.#t>=3&&u.condition(D.not(D.isAutocommit(o)));const h=u.query(l);return h.catch(()=>{}),a=u,h}),await o.execute()}const i=[];for(const o of n){const a=await o;if(a===void 0)throw new q("Statement in a transaction was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");i.push(rt(a))}return i}catch(r){throw O(r)}}async executeMultiple(e){const s=this._getStream();if(s.closed)throw new q("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#s===void 0){this.#s=s.run(yt(this.#e)).then(()=>{});try{await this.#s}catch(r){throw this.close(),r}}else await this.#s;await s.sequence(e)}catch(r){throw O(r)}}async rollback(){try{const e=this._getStream();if(e.closed||this.#s===void 0)return;const s=e.run("ROLLBACK").catch(r=>{throw O(r)});e.closeGracefully(),await s}catch(e){throw O(e)}finally{this.close()}}async commit(){try{const e=this._getStream();if(e.closed)throw new q("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#s!==void 0)await this.#s;else return;const s=e.run("COMMIT").catch(r=>{throw O(r)});e.closeGracefully(),await s}catch(e){throw O(e)}finally{this.close()}}}async function hr(t,e,s,r){const n=s.step(),i=n.run(yt(t));let o=n;const a=r.map(w=>{const S=s.step().condition(D.ok(o));e>=3&&S.condition(D.not(D.isAutocommit(s)));const T=S.query(w);return o=S,T}),l=s.step().condition(D.ok(o));e>=3&&l.condition(D.not(D.isAutocommit(s)));const u=l.run("COMMIT");s.step().condition(D.not(D.ok(l))).run("ROLLBACK").catch(w=>{}),await s.execute();const p=[];await i;for(const w of a){const S=await w;if(S===void 0)throw new q("Statement in a batch was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");p.push(rt(S))}return await u,p}function Qe(t){if(typeof t=="string")return new _t(t);const e=new _t(t.sql);if(Array.isArray(t.args))e.bindIndexes(t.args);else for(const[s,r]of Object.entries(t.args))e.bindName(s,r);return e}function rt(t){const e=t.columnNames.map(o=>o??""),s=t.columnDecltypes.map(o=>o??""),r=t.rows,n=t.affectedRowCount,i=t.lastInsertRowid!==void 0?t.lastInsertRowid:void 0;return new Gr(e,s,r,n,i)}function O(t){if(t instanceof C){const e=dr(t);return new q(t.message,e,void 0,t)}return t}function dr(t){return t instanceof Ps&&t.code!==void 0?t.code:t instanceof b?"HRANA_PROTO_ERROR":t instanceof W?t.cause instanceof C?dr(t.cause):"HRANA_CLOSED_ERROR":t instanceof wt?"HRANA_WEBSOCKET_ERROR":t instanceof Ds?"SERVER_ERROR":t instanceof be?"PROTOCOL_VERSION_ERROR":t instanceof se?"INTERNAL_ERROR":"UNKNOWN"}class Mt{#e;#t;capacity;constructor(e,s){this.#e=e,this.#t=new ji,this.capacity=s}apply(e){if(this.capacity<=0)return;const s=new Set;for(const r of e){if(typeof r.sql!="string")continue;const n=r.sql;if(n.length>=5e3)continue;let i=this.#t.get(n);if(i===void 0){for(;this.#t.size+1>this.capacity;){const[o,a]=this.#t.peekLru();if(s.has(a))break;a.close(),this.#t.delete(o)}this.#t.size+1<=this.capacity&&(i=this.#e.storeSql(n),this.#t.set(n,i))}i!==void 0&&(r.sql=i,s.add(i))}}}class ji{#e;constructor(){this.#e=new Map}get(e){const s=this.#e.get(e);return s!==void 0&&(this.#e.delete(e),this.#e.set(e,s)),s}set(e,s){this.#e.set(e,s)}peekLru(){for(const e of this.#e.entries())return e}delete(e){this.#e.delete(e)}get size(){return this.#e.size}}const Vi=1e3,zi=30;async function Ki(t){return new Promise(e=>{setTimeout(e,t)})}async function Wi({authToken:t,baseUrl:e,jobId:s}){const r=Ft(e+`/v1/jobs/${s}`),n=await fetch(r,{method:"GET",headers:{Authorization:`Bearer ${t}`}}),o=await n.json();if(n.status!==200)throw new Error(`Unexpected status code while fetching job status for migration with id ${s}: ${n.status}`);if(o.status=="RunFailure")throw new Error("Migration job failed");return o.status=="RunSuccess"}function Ft(t){return t.startsWith("ws://")?t.replace("ws://","http://"):t.startsWith("wss://")?t.replace("wss://","https://"):t}async function fr({authToken:t,baseUrl:e}){try{if(e.startsWith("http://127.0.0.1"))return!1;const s=Ft(e+"/v1/jobs"),r=await fetch(s,{method:"GET",headers:{Authorization:`Bearer ${t}`}});if(r.status===404||r.status===500)return!1;const n=await r.json();return!(r.status===400&&n.error==="Invalid namespace")}catch(s){throw console.error(["There has been an error while retrieving the database type.","Debug information:",`- URL: ${e}`,"- Response Status Code: N/A"].join(`
`)),s}}async function Ji({authToken:t,baseUrl:e}){const s=Ft(e+"/v1/jobs"),r=await fetch(s,{method:"GET",headers:{Authorization:`Bearer ${t}`}});if(r.status!==200)throw new Error("Unexpected status code while fetching migration jobs: "+r.status);const n=await r.json();if(!n.migrations||n.migrations.length===0)throw new Error("No migrations found");const i=n.migrations||[];let o;for(const a of i)a.job_id>(o?.job_id||0)&&(o=a);if(!o)throw new Error("No migration job found");if(o?.status==="RunFailure")throw new Error("Last migration job failed");return o}async function Ye({authToken:t,baseUrl:e}){const s=await Ji({authToken:t,baseUrl:e});if(s.status!=="RunSuccess"){let r=0;for(;r<zi&&(r++,!await Wi({authToken:t,baseUrl:e,jobId:s.job_id}));)await Ki(Vi)}}function Hi(t){var e=0,s=[];function r(){e--,e<t&&n()}function n(){var l=s.shift();a.queue=s.length,l&&o(l.fn).then(l.resolve).catch(l.reject)}function i(l){return new Promise(function(u,h){s.push({fn:l,resolve:u,reject:h}),a.queue=s.length})}function o(l){e++;try{return Promise.resolve(l()).then(function(u){return r(),u},function(u){throw r(),u})}catch(u){return r(),Promise.reject(u)}}var a=function(l){return e>=t?i(l):o(l)};return a}function Gi(t,e){var s=!1,r=this;return Promise.all(t.map(function(){var n=arguments;return r(function(){if(!s)return e.apply(void 0,n).catch(function(i){throw s=!0,i})})}))}function ls(t){return t.queue=0,t.map=Gi,t}var Xi=function(t){return ls(t?Hi(t):function(e){return e()})};const pr=Ar(Xi);function Yi(t){if(t.scheme!=="wss"&&t.scheme!=="ws")throw new q(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(t.scheme+":")}. For more information, please read ${Oe}`,"URL_SCHEME_NOT_SUPPORTED");if(t.encryptionKey!==void 0)throw new q("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(t.scheme==="ws"&&t.tls)throw new q('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");if(t.scheme==="wss"&&!t.tls)throw new q('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");const e=ft(t.scheme,t.authority,t.path);let s;try{s=ur(e,t.authToken)}catch(r){if(r instanceof Us){const n=t.scheme==="wss"?"https":"http",i=ft(n,t.authority,t.path);throw new q(`This environment does not support WebSockets, please switch to the HTTP client by using a "${n}:" URL (${JSON.stringify(i)}). For more information, please read ${Oe}`,"WEBSOCKETS_NOT_SUPPORTED")}throw O(r)}return new to(s,e,t.authToken,t.intMode,t.concurrency)}const Zi=60*1e3,eo=100;class to{#e;#t;#s;#r;#i;closed;protocol;#n;#a;constructor(e,s,r,n,i){this.#e=s,this.#t=r,this.#s=n,this.#r=this.#l(e),this.#i=void 0,this.closed=!1,this.protocol="ws",this.#a=pr(i)}getIsSchemaDatabase(){return this.#n===void 0&&(this.#n=fr({authToken:this.#t,baseUrl:this.#e.origin})),this.#n}async limit(e){return this.#a(e)}async execute(e){return this.limit(async()=>{const s=await this.#o();try{const r=this.getIsSchemaDatabase(),n=Qe(e);s.conn.sqlCache.apply([n]);const i=s.stream.query(n);s.stream.closeGracefully();const o=await i;return await r&&await Ye({authToken:this.#t,baseUrl:this.#e.origin}),rt(o)}catch(r){throw O(r)}finally{this._closeStream(s)}})}async batch(e,s="deferred"){return this.limit(async()=>{const r=await this.#o();try{const n=this.getIsSchemaDatabase(),i=e.map(Qe),o=await r.conn.client.getVersion();r.conn.sqlCache.apply(i);const a=r.stream.batch(o>=3),u=await hr(s,o,a,i);return await n&&await Ye({authToken:this.#t,baseUrl:this.#e.origin}),u}catch(n){throw O(n)}finally{this._closeStream(r)}})}async transaction(e="write"){return this.limit(async()=>{const s=await this.#o();try{const r=await s.conn.client.getVersion();return new so(this,s,e,r)}catch(r){throw this._closeStream(s),O(r)}})}async executeMultiple(e){return this.limit(async()=>{const s=await this.#o();try{const r=s.stream.sequence(e);s.stream.closeGracefully(),await r}catch(r){throw O(r)}finally{this._closeStream(s)}})}sync(){return Promise.resolve()}async#o(){if(this.closed)throw new q("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#r.openTime.valueOf()>Zi&&this.#i===void 0){const n=this.#l();this.#i=n,n.client.getVersion().then(i=>{this.#r!==n&&this.#r.streamStates.size===0&&this.#r.client.close(),this.#r=n,this.#i=void 0},i=>{this.#i=void 0})}if(this.#r.client.closed)try{this.#i!==void 0?this.#r=this.#i:this.#r=this.#l()}catch(n){throw O(n)}const r=this.#r;try{r.useSqlCache===void 0&&(r.useSqlCache=await r.client.getVersion()>=2,r.useSqlCache&&(r.sqlCache.capacity=eo));const n=r.client.openStream();n.intMode=this.#s;const i={conn:r,stream:n};return r.streamStates.add(i),i}catch(n){throw O(n)}}#l(e){try{return e??=ur(this.#e,this.#t),{client:e,useSqlCache:void 0,sqlCache:new Mt(e,0),openTime:new Date,streamStates:new Set}}catch(s){throw O(s)}}_closeStream(e){e.stream.close();const s=e.conn;s.streamStates.delete(e),s.streamStates.size===0&&s!==this.#r&&s.client.close()}close(){this.#r.client.close(),this.closed=!0}}class so extends cr{#e;#t;constructor(e,s,r,n){super(r,n),this.#e=e,this.#t=s}_getStream(){return this.#t.stream}_getSqlCache(){return this.#t.conn.sqlCache}close(){this.#e._closeStream(this.#t)}get closed(){return this.#t.stream.closed}}function ro(t){if(t.scheme!=="https"&&t.scheme!=="http")throw new q(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(t.scheme+":")}. For more information, please read ${Oe}`,"URL_SCHEME_NOT_SUPPORTED");if(t.encryptionKey!==void 0)throw new q("Encryption key is not supported by the remote client.","ENCRYPTION_KEY_NOT_SUPPORTED");if(t.scheme==="http"&&t.tls)throw new q('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");if(t.scheme==="https"&&!t.tls)throw new q('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");const e=ft(t.scheme,t.authority,t.path);return new no(e,t.authToken,t.intMode,t.fetch,t.concurrency)}const mr=30;class no{#e;protocol;#t;#s;#r;#i;constructor(e,s,r,n,i){this.#e=Fi(e,s,n),this.#e.intMode=r,this.protocol="http",this.#t=e,this.#s=s,this.#i=pr(i)}getIsSchemaDatabase(){return this.#r===void 0&&(this.#r=fr({authToken:this.#s,baseUrl:this.#t.origin})),this.#r}async limit(e){return this.#i(e)}async execute(e){return this.limit(async()=>{try{const s=this.getIsSchemaDatabase(),r=Qe(e);let n;const i=this.#e.openStream();try{n=i.query(r)}finally{i.closeGracefully()}const o=await n;return await s&&await Ye({authToken:this.#s,baseUrl:this.#t.origin}),rt(o)}catch(s){throw O(s)}})}async batch(e,s="deferred"){return this.limit(async()=>{try{const r=this.getIsSchemaDatabase(),n=e.map(Qe),i=await this.#e.getVersion();let o;const a=this.#e.openStream();try{new Mt(a,mr).apply(n);const p=a.batch(!1);o=hr(s,i,p,n)}finally{a.closeGracefully()}const l=await o;return await r&&await Ye({authToken:this.#s,baseUrl:this.#t.origin}),l}catch(r){throw O(r)}})}async transaction(e="write"){return this.limit(async()=>{try{const s=await this.#e.getVersion();return new io(this.#e.openStream(),e,s)}catch(s){throw O(s)}})}async executeMultiple(e){return this.limit(async()=>{try{let s;const r=this.#e.openStream();try{s=r.sequence(e)}finally{r.closeGracefully()}await s}catch(s){throw O(s)}})}sync(){throw new q("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#e.close()}get closed(){return this.#e.closed}}class io extends cr{#e;#t;constructor(e,s,r){super(s,r),this.#e=e,this.#t=new Mt(e,mr)}_getStream(){return this.#e}_getSqlCache(){return this.#t}close(){this.#e.close()}get closed(){return this.#e.closed}}function oo(t){return ao(Zr(t))}function ao(t){if(t.scheme==="ws"||t.scheme==="wss")return Yi(t);if(t.scheme==="http"||t.scheme==="https")return ro(t);throw new q(`The client that uses Web standard APIs supports only "libsql:", "wss:", "ws:", "https:" and "http:" URLs, got ${JSON.stringify(t.scheme+":")}. For more information, please read ${Oe}`,"URL_SCHEME_NOT_SUPPORTED")}const f=Symbol.for("drizzle:entityKind");function d(t,e){if(!t||typeof t!="object")return!1;if(t instanceof e)return!0;if(!Object.prototype.hasOwnProperty.call(e,f))throw new Error(`Class "${e.name??"<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);let s=t.constructor;if(s)for(;s;){if(f in s&&s[f]===e[f])return!0;s=Object.getPrototypeOf(s)}return!1}class lo{static[f]="ConsoleLogWriter";write(e){console.log(e)}}class uo{static[f]="DefaultLogger";writer;constructor(e){this.writer=e?.writer??new lo}logQuery(e,s){const r=s.map(i=>{try{return JSON.stringify(i)}catch{return String(i)}}),n=r.length?` -- params: [${r.join(", ")}]`:"";this.writer.write(`Query: ${e}${n}`)}}class co{static[f]="NoopLogger";logQuery(){}}const $e=Symbol.for("drizzle:Name"),Ke=Symbol.for("drizzle:Schema"),us=Symbol.for("drizzle:Columns"),cs=Symbol.for("drizzle:ExtraConfigColumns"),ct=Symbol.for("drizzle:OriginalName"),ht=Symbol.for("drizzle:BaseName"),hs=Symbol.for("drizzle:IsAlias"),ds=Symbol.for("drizzle:ExtraConfigBuilder");class y{static[f]="Table";static Symbol={Name:$e,Schema:Ke,OriginalName:ct,Columns:us,ExtraConfigColumns:cs,BaseName:ht,IsAlias:hs,ExtraConfigBuilder:ds};[$e];[ct];[Ke];[us];[cs];[ht];[hs]=!1;[ds]=void 0;constructor(e,s,r){this[$e]=this[ct]=e,this[Ke]=s,this[ht]=r}}function me(t){return t[$e]}function Be(t){return`${t[Ke]??"public"}.${t[$e]}`}class v{constructor(e,s){this.table=e,this.config=s,this.name=s.name,this.notNull=s.notNull,this.default=s.default,this.defaultFn=s.defaultFn,this.onUpdateFn=s.onUpdateFn,this.hasDefault=s.hasDefault,this.primary=s.primaryKey,this.isUnique=s.isUnique,this.uniqueName=s.uniqueName,this.uniqueType=s.uniqueType,this.dataType=s.dataType,this.columnType=s.columnType}static[f]="Column";name;primary;notNull;default;defaultFn;onUpdateFn;hasDefault;isUnique;uniqueName;uniqueType;dataType;columnType;enumValues=void 0;config;mapFromDriverValue(e){return e}mapToDriverValue(e){return e}}const fs=Symbol.for("drizzle:PgInlineForeignKeys");class ho extends y{static[f]="PgTable";static Symbol=Object.assign({},y.Symbol,{InlineForeignKeys:fs});[fs]=[];[y.Symbol.ExtraConfigBuilder]=void 0}class fo{static[f]="PgPrimaryKeyBuilder";columns;name;constructor(e,s){this.columns=e,this.name=s}build(e){return new po(e,this.columns,this.name)}}class po{constructor(e,s,r){this.table=e,this.columns=s,this.name=r}static[f]="PgPrimaryKey";columns;name;getName(){return this.name??`${this.table[ho.Symbol.Name]}_${this.columns.map(e=>e.name).join("_")}_pk`}}class mo{static[f]="ColumnBuilder";config;constructor(e,s,r){this.config={name:e,notNull:!1,default:void 0,hasDefault:!1,primaryKey:!1,isUnique:!1,uniqueName:void 0,uniqueType:void 0,dataType:s,columnType:r}}$type(){return this}notNull(){return this.config.notNull=!0,this}default(e){return this.config.default=e,this.config.hasDefault=!0,this}$defaultFn(e){return this.config.defaultFn=e,this.config.hasDefault=!0,this}$default=this.$defaultFn;$onUpdateFn(e){return this.config.onUpdateFn=e,this.config.hasDefault=!0,this}$onUpdate=this.$onUpdateFn;primaryKey(){return this.config.primaryKey=!0,this.config.notNull=!0,this}}const ps=Symbol.for("drizzle:isPgEnum");function yo(t){return!!t&&typeof t=="function"&&ps in t&&t[ps]===!0}class Y{static[f]="Subquery";constructor(e,s,r,n=!1){this._={brand:"Subquery",sql:e,selectedFields:s,alias:r,isWith:n}}}class yr extends Y{static[f]="WithSubquery"}const wo={startActiveSpan(t,e){return e()}},M=Symbol.for("drizzle:ViewBaseConfig");function wr(t){return t!=null&&typeof t.getSQL=="function"}function bo(t){const e={sql:"",params:[]};for(const s of t)e.sql+=s.sql,e.params.push(...s.params),s.typings?.length&&(e.typings||(e.typings=[]),e.typings.push(...s.typings));return e}class B{static[f]="StringChunk";value;constructor(e){this.value=Array.isArray(e)?e:[e]}getSQL(){return new m([this])}}class m{constructor(e){this.queryChunks=e}static[f]="SQL";decoder=br;shouldInlineParams=!1;append(e){return this.queryChunks.push(...e.queryChunks),this}toQuery(e){return wo.startActiveSpan("drizzle.buildSQL",s=>{const r=this.buildQueryFromSourceParams(this.queryChunks,e);return s?.setAttributes({"drizzle.query.text":r.sql,"drizzle.query.params":JSON.stringify(r.params)}),r})}buildQueryFromSourceParams(e,s){const r=Object.assign({},s,{inlineParams:s.inlineParams||this.shouldInlineParams,paramStartIndex:s.paramStartIndex||{value:0}}),{escapeName:n,escapeParam:i,prepareTyping:o,inlineParams:a,paramStartIndex:l}=r;return bo(e.map(u=>{if(d(u,B))return{sql:u.value.join(""),params:[]};if(d(u,Tt))return{sql:n(u.value),params:[]};if(u===void 0)return{sql:"",params:[]};if(Array.isArray(u)){const h=[new B("(")];for(const[p,w]of u.entries())h.push(w),p<u.length-1&&h.push(new B(", "));return h.push(new B(")")),this.buildQueryFromSourceParams(h,r)}if(d(u,m))return this.buildQueryFromSourceParams(u.queryChunks,{...r,inlineParams:a||u.shouldInlineParams});if(d(u,y)){const h=u[y.Symbol.Schema],p=u[y.Symbol.Name];return{sql:h===void 0?n(p):n(h)+"."+n(p),params:[]}}if(d(u,v))return s.invokeSource==="indexes"?{sql:n(u.name),params:[]}:{sql:n(u.table[y.Symbol.Name])+"."+n(u.name),params:[]};if(d(u,xe)){const h=u[M].schema,p=u[M].name;return{sql:h===void 0?n(p):n(h)+"."+n(p),params:[]}}if(d(u,ae)){const h=u.value===null?null:u.encoder.mapToDriverValue(u.value);if(d(h,m))return this.buildQueryFromSourceParams([h],r);if(a)return{sql:this.mapInlineParam(h,r),params:[]};let p;return o&&(p=[o(u.encoder)]),{sql:i(l.value++,h),params:[h],typings:p}}return d(u,nt)?{sql:i(l.value++,u),params:[u],typings:["none"]}:d(u,m.Aliased)&&u.fieldAlias!==void 0?{sql:n(u.fieldAlias),params:[]}:d(u,Y)?u._.isWith?{sql:n(u._.alias),params:[]}:this.buildQueryFromSourceParams([new B("("),u._.sql,new B(") "),new Tt(u._.alias)],r):yo(u)?u.schema?{sql:n(u.schema)+"."+n(u.enumName),params:[]}:{sql:n(u.enumName),params:[]}:wr(u)?u.shouldOmitSQLParens?.()?this.buildQueryFromSourceParams([u.getSQL()],r):this.buildQueryFromSourceParams([new B("("),u.getSQL(),new B(")")],r):a?{sql:this.mapInlineParam(u,r),params:[]}:{sql:i(l.value++,u),params:[u]}}))}mapInlineParam(e,{escapeString:s}){if(e===null)return"null";if(typeof e=="number"||typeof e=="boolean")return e.toString();if(typeof e=="string")return s(e);if(typeof e=="object"){const r=e.toString();return s(r==="[object Object]"?JSON.stringify(e):r)}throw new Error("Unexpected param value: "+e)}getSQL(){return this}as(e){return e===void 0?this:new m.Aliased(this,e)}mapWith(e){return this.decoder=typeof e=="function"?{mapFromDriverValue:e}:e,this}inlineParams(){return this.shouldInlineParams=!0,this}if(e){return e?this:void 0}}class Tt{constructor(e){this.value=e}static[f]="Name";brand;getSQL(){return new m([this])}}function go(t){return typeof t=="object"&&t!==null&&"mapToDriverValue"in t&&typeof t.mapToDriverValue=="function"}const br={mapFromDriverValue:t=>t},gr={mapToDriverValue:t=>t};({...br,...gr});class ae{constructor(e,s=gr){this.value=e,this.encoder=s}static[f]="Param";brand;getSQL(){return new m([this])}}function c(t,...e){const s=[];(e.length>0||t.length>0&&t[0]!=="")&&s.push(new B(t[0]));for(const[r,n]of e.entries())s.push(n,new B(t[r+1]));return new m(s)}(t=>{function e(){return new m([])}t.empty=e;function s(l){return new m(l)}t.fromList=s;function r(l){return new m([new B(l)])}t.raw=r;function n(l,u){const h=[];for(const[p,w]of l.entries())p>0&&u!==void 0&&h.push(u),h.push(w);return new m(h)}t.join=n;function i(l){return new Tt(l)}t.identifier=i;function o(l){return new nt(l)}t.placeholder=o;function a(l,u){return new ae(l,u)}t.param=a})(c||(c={}));(t=>{class e{constructor(r,n){this.sql=r,this.fieldAlias=n}static[f]="SQL.Aliased";isSelectionField=!1;getSQL(){return this.sql}clone(){return new e(this.sql,this.fieldAlias)}}t.Aliased=e})(m||(m={}));class nt{constructor(e){this.name=e}static[f]="Placeholder";getSQL(){return new m([this])}}function Fe(t,e){return t.map(s=>{if(d(s,nt)){if(!(s.name in e))throw new Error(`No value for placeholder "${s.name}" was provided`);return e[s.name]}return s})}class xe{static[f]="View";[M];constructor({name:e,schema:s,selectedFields:r,query:n}){this[M]={name:e,originalName:e,schema:s,selectedFields:r,query:n,isExisting:!n,isAlias:!1}}getSQL(){return new m([this])}}v.prototype.getSQL=function(){return new m([this])};y.prototype.getSQL=function(){return new m([this])};Y.prototype.getSQL=function(){return new m([this])};function F(t,e){return go(e)&&!wr(t)&&!d(t,ae)&&!d(t,nt)&&!d(t,v)&&!d(t,y)&&!d(t,xe)?new ae(t,e):t}const Sr=(t,e)=>c`${t} = ${F(e,t)}`,So=(t,e)=>c`${t} <> ${F(e,t)}`;function xt(...t){const e=t.filter(s=>s!==void 0);if(e.length!==0)return e.length===1?new m(e):new m([new B("("),c.join(e,new B(" and ")),new B(")")])}function _o(...t){const e=t.filter(s=>s!==void 0);if(e.length!==0)return e.length===1?new m(e):new m([new B("("),c.join(e,new B(" or ")),new B(")")])}function qo(t){return c`not ${t}`}const Ro=(t,e)=>c`${t} > ${F(e,t)}`,To=(t,e)=>c`${t} >= ${F(e,t)}`,xo=(t,e)=>c`${t} < ${F(e,t)}`,No=(t,e)=>c`${t} <= ${F(e,t)}`;function Co(t,e){if(Array.isArray(e)){if(e.length===0)throw new Error("inArray requires at least one value");return c`${t} in ${e.map(s=>F(s,t))}`}return c`${t} in ${F(e,t)}`}function Eo(t,e){if(Array.isArray(e)){if(e.length===0)throw new Error("notInArray requires at least one value");return c`${t} not in ${e.map(s=>F(s,t))}`}return c`${t} not in ${F(e,t)}`}function Io(t){return c`${t} is null`}function Lo(t){return c`${t} is not null`}function Ao(t){return c`exists ${t}`}function $o(t){return c`not exists ${t}`}function Oo(t,e,s){return c`${t} between ${F(e,t)} and ${F(s,t)}`}function vo(t,e,s){return c`${t} not between ${F(e,t)} and ${F(s,t)}`}function Qo(t,e){return c`${t} like ${e}`}function Bo(t,e){return c`${t} not like ${e}`}function Po(t,e){return c`${t} ilike ${e}`}function Uo(t,e){return c`${t} not ilike ${e}`}function Do(t){return c`${t} asc`}function ko(t){return c`${t} desc`}class _r{constructor(e,s,r){this.sourceTable=e,this.referencedTable=s,this.relationName=r,this.referencedTableName=s[y.Symbol.Name]}static[f]="Relation";referencedTableName;fieldName}class Mo{constructor(e,s){this.table=e,this.config=s}static[f]="Relations"}class le extends _r{constructor(e,s,r,n){super(e,s,r?.relationName),this.config=r,this.isNullable=n}static[f]="One";withFieldName(e){const s=new le(this.sourceTable,this.referencedTable,this.config,this.isNullable);return s.fieldName=e,s}}class it extends _r{constructor(e,s,r){super(e,s,r?.relationName),this.config=r}static[f]="Many";withFieldName(e){const s=new it(this.sourceTable,this.referencedTable,this.config);return s.fieldName=e,s}}function Fo(){return{and:xt,between:Oo,eq:Sr,exists:Ao,gt:Ro,gte:To,ilike:Po,inArray:Co,isNull:Io,isNotNull:Lo,like:Qo,lt:xo,lte:No,ne:So,not:qo,notBetween:vo,notExists:$o,notLike:Bo,notIlike:Uo,notInArray:Eo,or:_o,sql:c}}function jo(){return{sql:c,asc:Do,desc:ko}}function Vo(t,e){Object.keys(t).length===1&&"default"in t&&!d(t.default,y)&&(t=t.default);const s={},r={},n={};for(const[i,o]of Object.entries(t))if(d(o,y)){const a=Be(o),l=r[a];s[a]=i,n[i]={tsName:i,dbName:o[y.Symbol.Name],schema:o[y.Symbol.Schema],columns:o[y.Symbol.Columns],relations:l?.relations??{},primaryKey:l?.primaryKey??[]};for(const h of Object.values(o[y.Symbol.Columns]))h.primary&&n[i].primaryKey.push(h);const u=o[y.Symbol.ExtraConfigBuilder]?.(o[y.Symbol.ExtraConfigColumns]);if(u)for(const h of Object.values(u))d(h,fo)&&n[i].primaryKey.push(...h.columns)}else if(d(o,Mo)){const a=Be(o.table),l=s[a],u=o.config(e(o.table));let h;for(const[p,w]of Object.entries(u))if(l){const S=n[l];S.relations[p]=w}else a in r||(r[a]={relations:{},primaryKey:h}),r[a].relations[p]=w}return{tables:n,tableNamesMap:s}}function zo(t){return function(s,r){return new le(t,s,r,r?.fields.reduce((n,i)=>n&&i.notNull,!0)??!1)}}function Ko(t){return function(s,r){return new it(t,s,r)}}function Wo(t,e,s){if(d(s,le)&&s.config)return{fields:s.config.fields,references:s.config.references};const r=e[Be(s.referencedTable)];if(!r)throw new Error(`Table "${s.referencedTable[y.Symbol.Name]}" not found in schema`);const n=t[r];if(!n)throw new Error(`Table "${r}" not found in schema`);const i=s.sourceTable,o=e[Be(i)];if(!o)throw new Error(`Table "${i[y.Symbol.Name]}" not found in schema`);const a=[];for(const l of Object.values(n.relations))(s.relationName&&s!==l&&l.relationName===s.relationName||!s.relationName&&l.referencedTable===s.sourceTable)&&a.push(l);if(a.length>1)throw s.relationName?new Error(`There are multiple relations with name "${s.relationName}" in table "${r}"`):new Error(`There are multiple relations between "${r}" and "${s.sourceTable[y.Symbol.Name]}". Please specify relation name`);if(a[0]&&d(a[0],le)&&a[0].config)return{fields:a[0].config.references,references:a[0].config.fields};throw new Error(`There is not enough information to infer relation "${o}.${s.fieldName}"`)}function Jo(t){return{one:zo(t),many:Ko(t)}}function Nt(t,e,s,r,n=i=>i){const i={};for(const[o,a]of r.entries())if(a.isJson){const l=e.relations[a.tsKey],u=s[o],h=typeof u=="string"?JSON.parse(u):u;i[a.tsKey]=d(l,le)?h&&Nt(t,t[a.relationTableTsKey],h,a.selection,n):h.map(p=>Nt(t,t[a.relationTableTsKey],p,a.selection,n))}else{const l=n(s[o]),u=a.field;let h;d(u,v)?h=u:d(u,m)?h=u.decoder:h=u.sql.decoder,i[a.tsKey]=l===null?null:h.mapFromDriverValue(l)}return i}class Ze{constructor(e){this.table=e}static[f]="ColumnAliasProxyHandler";get(e,s){return s==="table"?this.table:e[s]}}class jt{constructor(e,s){this.alias=e,this.replaceOriginalName=s}static[f]="TableAliasProxyHandler";get(e,s){if(s===y.Symbol.IsAlias)return!0;if(s===y.Symbol.Name)return this.alias;if(this.replaceOriginalName&&s===y.Symbol.OriginalName)return this.alias;if(s===M)return{...e[M],name:this.alias,isAlias:!0};if(s===y.Symbol.Columns){const n=e[y.Symbol.Columns];if(!n)return n;const i={};return Object.keys(n).map(o=>{i[o]=new Proxy(n[o],new Ze(new Proxy(e,this)))}),i}const r=e[s];return d(r,v)?new Proxy(r,new Ze(new Proxy(e,this))):r}}function dt(t,e){return new Proxy(t,new jt(e,!1))}function ee(t,e){return new Proxy(t,new Ze(new Proxy(t.table,new jt(e,!1))))}function qr(t,e){return new m.Aliased(et(t.sql,e),t.fieldAlias)}function et(t,e){return c.join(t.queryChunks.map(s=>d(s,v)?ee(s,e):d(s,m)?et(s,e):d(s,m.Aliased)?qr(s,e):s))}class J{static[f]="SelectionProxyHandler";config;constructor(e){this.config={...e}}get(e,s){if(s==="_")return{...e._,selectedFields:new Proxy(e._.selectedFields,this)};if(s===M)return{...e[M],selectedFields:new Proxy(e[M].selectedFields,this)};if(typeof s=="symbol")return e[s];const n=(d(e,Y)?e._.selectedFields:d(e,xe)?e[M].selectedFields:e)[s];if(d(n,m.Aliased)){if(this.config.sqlAliasedBehavior==="sql"&&!n.isSelectionField)return n.sql;const i=n.clone();return i.isSelectionField=!0,i}if(d(n,m)){if(this.config.sqlBehavior==="sql")return n;throw new Error(`You tried to reference "${s}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`)}return d(n,v)?this.config.alias?new Proxy(n,new Ze(new Proxy(n.table,new jt(this.config.alias,this.config.replaceOriginalName??!1)))):n:typeof n!="object"||n===null?n:new Proxy(n,new J(this.config))}}class he{static[f]="QueryPromise";[Symbol.toStringTag]="QueryPromise";catch(e){return this.then(void 0,e)}finally(e){return this.then(s=>(e?.(),s),s=>{throw e?.(),s})}then(e,s){return this.execute().then(e,s)}}const Ct=Symbol.for("drizzle:SQLiteInlineForeignKeys");class K extends y{static[f]="SQLiteTable";static Symbol=Object.assign({},y.Symbol,{InlineForeignKeys:Ct});[y.Symbol.Columns];[Ct]=[];[y.Symbol.ExtraConfigBuilder]=void 0}function Ho(t,e,s,r,n=t){const i=new K(t,r,n),o=Object.fromEntries(Object.entries(e).map(([l,u])=>{const h=u,p=h.build(i);return i[Ct].push(...h.buildForeignKeys(p,i)),[l,p]})),a=Object.assign(i,o);return a[y.Symbol.Columns]=o,a[y.Symbol.ExtraConfigColumns]=o,a}const ot=(t,e,s)=>Ho(t,e);function ms(t,e,s){const r={},n=t.reduce((i,{path:o,field:a},l)=>{let u;d(a,v)?u=a:d(a,m)?u=a.decoder:u=a.sql.decoder;let h=i;for(const[p,w]of o.entries())if(p<o.length-1)w in h||(h[w]={}),h=h[w];else{const S=e[l],T=h[w]=S===null?null:u.mapFromDriverValue(S);if(s&&d(a,v)&&o.length===2){const N=o[0];N in r?typeof r[N]=="string"&&r[N]!==me(a.table)&&(r[N]=!1):r[N]=T===null?me(a.table):!1}}return i},{});if(s&&Object.keys(r).length>0)for(const[i,o]of Object.entries(r))typeof o=="string"&&!s[o]&&(n[i]=null);return n}function ue(t,e){return Object.entries(t).reduce((s,[r,n])=>{if(typeof r!="string")return s;const i=e?[...e,r]:[r];return d(n,v)||d(n,m)||d(n,m.Aliased)?s.push({path:i,field:n}):d(n,y)?s.push(...ue(n[y.Symbol.Columns],i)):s.push(...ue(n,i)),s},[])}function Rr(t,e){const s=Object.keys(t),r=Object.keys(e);if(s.length!==r.length)return!1;for(const[n,i]of s.entries())if(i!==r[n])return!1;return!0}function Tr(t,e){const s=Object.entries(e).filter(([,r])=>r!==void 0).map(([r,n])=>d(n,m)?[r,n]:[r,new ae(n,t[y.Symbol.Columns][r])]);if(s.length===0)throw new Error("No values to set");return Object.fromEntries(s)}function Go(t,e){for(const s of e)for(const r of Object.getOwnPropertyNames(s.prototype))r!=="constructor"&&Object.defineProperty(t.prototype,r,Object.getOwnPropertyDescriptor(s.prototype,r)||Object.create(null))}function Xo(t){return t[y.Symbol.Columns]}function ys(t){return d(t,Y)?t._.alias:d(t,xe)?t[M].name:d(t,m)?void 0:t[y.Symbol.IsAlias]?t[y.Symbol.Name]:t[y.Symbol.BaseName]}class ws extends he{constructor(e,s,r,n){super(),this.table=e,this.session=s,this.dialect=r,this.config={table:e,withList:n}}static[f]="SQLiteDelete";config;where(e){return this.config.where=e,this}returning(e=this.table[K.Symbol.Columns]){return this.config.returning=ue(e),this}getSQL(){return this.dialect.buildDeleteQuery(this.config)}toSQL(){const{typings:e,...s}=this.dialect.sqlToQuery(this.getSQL());return s}_prepare(e=!0){return this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0)}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(e){return this._prepare().execute(e)}$dynamic(){return this}}class bs{constructor(e,s,r,n){this.table=e,this.session=s,this.dialect=r,this.withList=n}static[f]="SQLiteInsertBuilder";values(e){if(e=Array.isArray(e)?e:[e],e.length===0)throw new Error("values() must be called with at least one value");const s=e.map(r=>{const n={},i=this.table[y.Symbol.Columns];for(const o of Object.keys(r)){const a=r[o];n[o]=d(a,m)?a:new ae(a,i[o])}return n});return new Yo(this.table,s,this.session,this.dialect,this.withList)}}class Yo extends he{constructor(e,s,r,n,i){super(),this.session=r,this.dialect=n,this.config={table:e,values:s,withList:i}}static[f]="SQLiteInsert";config;returning(e=this.config.table[K.Symbol.Columns]){return this.config.returning=ue(e),this}onConflictDoNothing(e={}){if(e.target===void 0)this.config.onConflict=c`do nothing`;else{const s=Array.isArray(e.target)?c`${e.target}`:c`${[e.target]}`,r=e.where?c` where ${e.where}`:c``;this.config.onConflict=c`${s} do nothing${r}`}return this}onConflictDoUpdate(e){if(e.where&&(e.targetWhere||e.setWhere))throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');const s=e.where?c` where ${e.where}`:void 0,r=e.targetWhere?c` where ${e.targetWhere}`:void 0,n=e.setWhere?c` where ${e.setWhere}`:void 0,i=Array.isArray(e.target)?c`${e.target}`:c`${[e.target]}`,o=this.dialect.buildUpdateSet(this.config.table,Tr(this.config.table,e.set));return this.config.onConflict=c`${i}${r} do update set ${o}${s}${n}`,this}getSQL(){return this.dialect.buildInsertQuery(this.config)}toSQL(){const{typings:e,...s}=this.dialect.sqlToQuery(this.getSQL());return s}_prepare(e=!0){return this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0)}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class Vt extends Error{static[f]="DrizzleError";constructor({message:e,cause:s}){super(e),this.name="DrizzleError",this.cause=s}}class Zo extends Vt{static[f]="TransactionRollbackError";constructor(){super({message:"Rollback"})}}class ea{static[f]="SQLiteForeignKeyBuilder";reference;_onUpdate;_onDelete;constructor(e,s){this.reference=()=>{const{name:r,columns:n,foreignColumns:i}=e();return{name:r,columns:n,foreignTable:i[0].table,foreignColumns:i}},s&&(this._onUpdate=s.onUpdate,this._onDelete=s.onDelete)}onUpdate(e){return this._onUpdate=e,this}onDelete(e){return this._onDelete=e,this}build(e){return new ta(e,this)}}class ta{constructor(e,s){this.table=e,this.reference=s.reference,this.onUpdate=s._onUpdate,this.onDelete=s._onDelete}static[f]="SQLiteForeignKey";reference;onUpdate;onDelete;getName(){const{name:e,columns:s,foreignColumns:r}=this.reference(),n=s.map(a=>a.name),i=r.map(a=>a.name),o=[this.table[K.Symbol.Name],...n,r[0].table[K.Symbol.Name],...i];return e??`${o.join("_")}_fk`}}function sa(t,e){return`${t[K.Symbol.Name]}_${e.join("_")}_unique`}class zt extends mo{static[f]="SQLiteColumnBuilder";foreignKeyConfigs=[];references(e,s={}){return this.foreignKeyConfigs.push({ref:e,actions:s}),this}unique(e){return this.config.isUnique=!0,this.config.uniqueName=e,this}buildForeignKeys(e,s){return this.foreignKeyConfigs.map(({ref:r,actions:n})=>((i,o)=>{const a=new ea(()=>{const l=i();return{columns:[e],foreignColumns:[l]}});return o.onUpdate&&a.onUpdate(o.onUpdate),o.onDelete&&a.onDelete(o.onDelete),a.build(s)})(r,n))}}class we extends v{constructor(e,s){s.uniqueName||(s.uniqueName=sa(e,[s.name])),super(e,s),this.table=e}static[f]="SQLiteColumn"}class Kt extends zt{static[f]="SQLiteBaseIntegerBuilder";constructor(e,s,r){super(e,s,r),this.config.autoIncrement=!1}primaryKey(e){return e?.autoIncrement&&(this.config.autoIncrement=!0),this.config.hasDefault=!0,super.primaryKey()}}class Wt extends we{static[f]="SQLiteBaseInteger";autoIncrement=this.config.autoIncrement;getSQLType(){return"integer"}}class ra extends Kt{static[f]="SQLiteIntegerBuilder";constructor(e){super(e,"number","SQLiteInteger")}build(e){return new na(e,this.config)}}class na extends Wt{static[f]="SQLiteInteger"}class ia extends Kt{static[f]="SQLiteTimestampBuilder";constructor(e,s){super(e,"date","SQLiteTimestamp"),this.config.mode=s}defaultNow(){return this.default(c`(cast((julianday('now') - 2440587.5)*86400000 as integer))`)}build(e){return new oa(e,this.config)}}class oa extends Wt{static[f]="SQLiteTimestamp";mode=this.config.mode;mapFromDriverValue(e){return this.config.mode==="timestamp"?new Date(e*1e3):new Date(e)}mapToDriverValue(e){const s=e.getTime();return this.config.mode==="timestamp"?Math.floor(s/1e3):s}}class aa extends Kt{static[f]="SQLiteBooleanBuilder";constructor(e,s){super(e,"boolean","SQLiteBoolean"),this.config.mode=s}build(e){return new la(e,this.config)}}class la extends Wt{static[f]="SQLiteBoolean";mode=this.config.mode;mapFromDriverValue(e){return Number(e)===1}mapToDriverValue(e){return e?1:0}}function j(t,e){return e?.mode==="timestamp"||e?.mode==="timestamp_ms"?new ia(t,e.mode):e?.mode==="boolean"?new aa(t,e.mode):new ra(t)}class ua extends zt{static[f]="SQLiteTextBuilder";constructor(e,s){super(e,"string","SQLiteText"),this.config.enumValues=s.enum,this.config.length=s.length}build(e){return new ca(e,this.config)}}class ca extends we{static[f]="SQLiteText";enumValues=this.config.enumValues;length=this.config.length;constructor(e,s){super(e,s)}getSQLType(){return`text${this.config.length?`(${this.config.length})`:""}`}}class ha extends zt{static[f]="SQLiteTextJsonBuilder";constructor(e){super(e,"json","SQLiteTextJson")}build(e){return new da(e,this.config)}}class da extends we{static[f]="SQLiteTextJson";getSQLType(){return"text"}mapFromDriverValue(e){return JSON.parse(e)}mapToDriverValue(e){return JSON.stringify(e)}}function k(t,e={}){return e.mode==="json"?new ha(t):new ua(t,e)}class xr extends xe{static[f]="SQLiteViewBase"}class Nr{static[f]="SQLiteDialect";escapeName(e){return`"${e}"`}escapeParam(e){return"?"}escapeString(e){return`'${e.replace(/'/g,"''")}'`}buildWithCTE(e){if(!e?.length)return;const s=[c`with `];for(const[r,n]of e.entries())s.push(c`${c.identifier(n._.alias)} as (${n._.sql})`),r<e.length-1&&s.push(c`, `);return s.push(c` `),c.join(s)}buildDeleteQuery({table:e,where:s,returning:r,withList:n}){const i=this.buildWithCTE(n),o=r?c` returning ${this.buildSelection(r,{isSingleTable:!0})}`:void 0,a=s?c` where ${s}`:void 0;return c`${i}delete from ${e}${a}${o}`}buildUpdateSet(e,s){const r=e[y.Symbol.Columns],n=Object.keys(r).filter(o=>s[o]!==void 0||r[o]?.onUpdateFn!==void 0),i=n.length;return c.join(n.flatMap((o,a)=>{const l=r[o],u=s[o]??c.param(l.onUpdateFn(),l),h=c`${c.identifier(l.name)} = ${u}`;return a<i-1?[h,c.raw(", ")]:[h]}))}buildUpdateQuery({table:e,set:s,where:r,returning:n,withList:i}){const o=this.buildWithCTE(i),a=this.buildUpdateSet(e,s),l=n?c` returning ${this.buildSelection(n,{isSingleTable:!0})}`:void 0,u=r?c` where ${r}`:void 0;return c`${o}update ${e} set ${a}${u}${l}`}buildSelection(e,{isSingleTable:s=!1}={}){const r=e.length,n=e.flatMap(({field:i},o)=>{const a=[];if(d(i,m.Aliased)&&i.isSelectionField)a.push(c.identifier(i.fieldAlias));else if(d(i,m.Aliased)||d(i,m)){const l=d(i,m.Aliased)?i.sql:i;s?a.push(new m(l.queryChunks.map(u=>d(u,v)?c.identifier(u.name):u))):a.push(l),d(i,m.Aliased)&&a.push(c` as ${c.identifier(i.fieldAlias)}`)}else if(d(i,v)){const l=i.table[y.Symbol.Name],u=i.name;s?a.push(c.identifier(u)):a.push(c`${c.identifier(l)}.${c.identifier(u)}`)}return o<r-1&&a.push(c`, `),a});return c.join(n)}buildSelectQuery({withList:e,fields:s,fieldsFlat:r,where:n,having:i,table:o,joins:a,orderBy:l,groupBy:u,limit:h,offset:p,distinct:w,setOperators:S}){const T=r??ue(s);for(const U of T)if(d(U.field,v)&&me(U.field.table)!==(d(o,Y)?o._.alias:d(o,xr)?o[M].name:d(o,m)?void 0:me(o))&&!(A=>a?.some(({alias:Z})=>Z===(A[y.Symbol.IsAlias]?me(A):A[y.Symbol.BaseName])))(U.field.table)){const A=me(U.field.table);throw new Error(`Your "${U.path.join("->")}" field references a column "${A}"."${U.field.name}", but the table "${A}" is not part of the query! Did you forget to join it?`)}const N=!a||a.length===0,I=this.buildWithCTE(e),L=w?c` distinct`:void 0,x=this.buildSelection(T,{isSingleTable:N}),$=d(o,y)&&o[y.Symbol.OriginalName]!==o[y.Symbol.Name]?c`${c.identifier(o[y.Symbol.OriginalName])} ${c.identifier(o[y.Symbol.Name])}`:o,R=[];if(a)for(const[U,A]of a.entries()){U===0&&R.push(c` `);const Z=A.table;if(d(Z,K)){const ut=Z[K.Symbol.Name],Xt=Z[K.Symbol.Schema],Yt=Z[K.Symbol.OriginalName],Zt=ut===Yt?void 0:A.alias;R.push(c`${c.raw(A.joinType)} join ${Xt?c`${c.identifier(Xt)}.`:void 0}${c.identifier(Yt)}${Zt&&c` ${c.identifier(Zt)}`} on ${A.on}`)}else R.push(c`${c.raw(A.joinType)} join ${Z} on ${A.on}`);U<a.length-1&&R.push(c` `)}const V=c.join(R),de=n?c` where ${n}`:void 0,g=i?c` having ${i}`:void 0,_=[];if(l)for(const[U,A]of l.entries())_.push(A),U<l.length-1&&_.push(c`, `);const z=[];if(u)for(const[U,A]of u.entries())z.push(A),U<u.length-1&&z.push(c`, `);const Ue=z.length>0?c` group by ${c.join(z)}`:void 0,lt=_.length>0?c` order by ${c.join(_)}`:void 0,Ne=h?c` limit ${h}`:void 0,De=p?c` offset ${p}`:void 0,ke=c`${I}select${L} ${x} from ${$}${V}${de}${Ue}${g}${lt}${Ne}${De}`;return S.length>0?this.buildSetOperations(ke,S):ke}buildSetOperations(e,s){const[r,...n]=s;if(!r)throw new Error("Cannot pass undefined values to any set operator");return n.length===0?this.buildSetOperationQuery({leftSelect:e,setOperator:r}):this.buildSetOperations(this.buildSetOperationQuery({leftSelect:e,setOperator:r}),n)}buildSetOperationQuery({leftSelect:e,setOperator:{type:s,isAll:r,rightSelect:n,limit:i,orderBy:o,offset:a}}){const l=c`${e.getSQL()} `,u=c`${n.getSQL()}`;let h;if(o&&o.length>0){const T=[];for(const N of o)if(d(N,we))T.push(c.identifier(N.name));else if(d(N,m)){for(let I=0;I<N.queryChunks.length;I++){const L=N.queryChunks[I];d(L,we)&&(N.queryChunks[I]=c.identifier(L.name))}T.push(c`${N}`)}else T.push(c`${N}`);h=c` order by ${c.join(T,c`, `)}`}const p=i?c` limit ${i}`:void 0,w=c.raw(`${s} ${r?"all ":""}`),S=a?c` offset ${a}`:void 0;return c`${l}${w}${u}${h}${p}${S}`}buildInsertQuery({table:e,values:s,onConflict:r,returning:n,withList:i}){const o=[],a=e[y.Symbol.Columns],l=Object.entries(a),u=l.map(([,T])=>c.identifier(T.name));for(const[T,N]of s.entries()){const I=[];for(const[L,x]of l){const $=N[L];if($===void 0||d($,ae)&&$.value===void 0){let R;if(x.default!==null&&x.default!==void 0)R=d(x.default,m)?x.default:c.param(x.default,x);else if(x.defaultFn!==void 0){const V=x.defaultFn();R=d(V,m)?V:c.param(V,x)}else if(!x.default&&x.onUpdateFn!==void 0){const V=x.onUpdateFn();R=d(V,m)?V:c.param(V,x)}else R=c`null`;I.push(R)}else I.push($)}o.push(I),T<s.length-1&&o.push(c`, `)}const h=this.buildWithCTE(i),p=c.join(o),w=n?c` returning ${this.buildSelection(n,{isSingleTable:!0})}`:void 0,S=r?c` on conflict ${r}`:void 0;return c`${h}insert into ${e} ${u} values ${p}${S}${w}`}sqlToQuery(e,s){return e.toQuery({escapeName:this.escapeName,escapeParam:this.escapeParam,escapeString:this.escapeString,invokeSource:s})}buildRelationalQuery({fullSchema:e,schema:s,tableNamesMap:r,table:n,tableConfig:i,queryConfig:o,tableAlias:a,nestedQueryRelation:l,joinOn:u}){let h=[],p,w,S=[],T;const N=[];if(o===!0)h=Object.entries(i.columns).map(([x,$])=>({dbKey:$.name,tsKey:x,field:ee($,a),relationTableTsKey:void 0,isJson:!1,selection:[]}));else{const L=Object.fromEntries(Object.entries(i.columns).map(([g,_])=>[g,ee(_,a)]));if(o.where){const g=typeof o.where=="function"?o.where(L,Fo()):o.where;T=g&&et(g,a)}const x=[];let $=[];if(o.columns){let g=!1;for(const[_,z]of Object.entries(o.columns))z!==void 0&&_ in i.columns&&(!g&&z===!0&&(g=!0),$.push(_));$.length>0&&($=g?$.filter(_=>o.columns?.[_]===!0):Object.keys(i.columns).filter(_=>!$.includes(_)))}else $=Object.keys(i.columns);for(const g of $){const _=i.columns[g];x.push({tsKey:g,value:_})}let R=[];o.with&&(R=Object.entries(o.with).filter(g=>!!g[1]).map(([g,_])=>({tsKey:g,queryConfig:_,relation:i.relations[g]})));let V;if(o.extras){V=typeof o.extras=="function"?o.extras(L,{sql:c}):o.extras;for(const[g,_]of Object.entries(V))x.push({tsKey:g,value:qr(_,a)})}for(const{tsKey:g,value:_}of x)h.push({dbKey:d(_,m.Aliased)?_.fieldAlias:i.columns[g].name,tsKey:g,field:d(_,v)?ee(_,a):_,relationTableTsKey:void 0,isJson:!1,selection:[]});let de=typeof o.orderBy=="function"?o.orderBy(L,jo()):o.orderBy??[];Array.isArray(de)||(de=[de]),S=de.map(g=>d(g,v)?ee(g,a):et(g,a)),p=o.limit,w=o.offset;for(const{tsKey:g,queryConfig:_,relation:z}of R){const Ue=Wo(s,r,z),lt=Be(z.referencedTable),Ne=r[lt],De=`${a}_${g}`,ke=xt(...Ue.fields.map((Z,ut)=>Sr(ee(Ue.references[ut],De),ee(Z,a)))),U=this.buildRelationalQuery({fullSchema:e,schema:s,tableNamesMap:r,table:e[Ne],tableConfig:s[Ne],queryConfig:d(z,le)?_===!0?{limit:1}:{..._,limit:1}:_,tableAlias:De,joinOn:ke,nestedQueryRelation:z}),A=c`(${U.sql})`.as(g);h.push({dbKey:g,tsKey:g,field:A,relationTableTsKey:Ne,isJson:!0,selection:U.selection})}}if(h.length===0)throw new Vt({message:`No fields selected for table "${i.tsName}" ("${a}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`});let I;if(T=xt(u,T),l){let L=c`json_array(${c.join(h.map(({field:R})=>d(R,we)?c.identifier(R.name):d(R,m.Aliased)?R.sql:R),c`, `)})`;d(l,it)&&(L=c`coalesce(json_group_array(${L}), json_array())`);const x=[{dbKey:"data",tsKey:"data",field:L.as("data"),isJson:!0,relationTableTsKey:i.tsName,selection:h}];p!==void 0||w!==void 0||S.length>0?(I=this.buildSelectQuery({table:dt(n,a),fields:{},fieldsFlat:[{path:[],field:c.raw("*")}],where:T,limit:p,offset:w,orderBy:S,setOperators:[]}),T=void 0,p=void 0,w=void 0,S=void 0):I=dt(n,a),I=this.buildSelectQuery({table:d(I,K)?I:new Y(I,{},a),fields:{},fieldsFlat:x.map(({field:R})=>({path:[],field:d(R,v)?ee(R,a):R})),joins:N,where:T,limit:p,offset:w,orderBy:S,setOperators:[]})}else I=this.buildSelectQuery({table:dt(n,a),fields:{},fieldsFlat:h.map(({field:L})=>({path:[],field:d(L,v)?ee(L,a):L})),joins:N,where:T,limit:p,offset:w,orderBy:S,setOperators:[]});return{tableTsKey:i.tsName,sql:I,selection:h}}}class fa extends Nr{static[f]="SQLiteSyncDialect";migrate(e,s,r){const n=r===void 0||typeof r=="string"?"__drizzle_migrations":r.migrationsTable??"__drizzle_migrations",i=c`
			CREATE TABLE IF NOT EXISTS ${c.identifier(n)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;s.run(i);const a=s.values(c`SELECT id, hash, created_at FROM ${c.identifier(n)} ORDER BY created_at DESC LIMIT 1`)[0]??void 0;s.run(c`BEGIN`);try{for(const l of e)if(!a||Number(a[2])<l.folderMillis){for(const u of l.sql)s.run(c.raw(u));s.run(c`INSERT INTO ${c.identifier(n)} ("hash", "created_at") VALUES(${l.hash}, ${l.folderMillis})`)}s.run(c`COMMIT`)}catch(l){throw s.run(c`ROLLBACK`),l}}}class pa extends Nr{static[f]="SQLiteAsyncDialect";async migrate(e,s,r){const n=r===void 0||typeof r=="string"?"__drizzle_migrations":r.migrationsTable??"__drizzle_migrations",i=c`
			CREATE TABLE IF NOT EXISTS ${c.identifier(n)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;await s.run(i);const a=(await s.values(c`SELECT id, hash, created_at FROM ${c.identifier(n)} ORDER BY created_at DESC LIMIT 1`))[0]??void 0;await s.transaction(async l=>{for(const u of e)if(!a||Number(a[2])<u.folderMillis){for(const h of u.sql)await l.run(c.raw(h));await l.run(c`INSERT INTO ${c.identifier(n)} ("hash", "created_at") VALUES(${u.hash}, ${u.folderMillis})`)}})}}class ma{static[f]="TypedQueryBuilder";getSelectedFields(){return this._.selectedFields}}class te{static[f]="SQLiteSelectBuilder";fields;session;dialect;withList;distinct;constructor(e){this.fields=e.fields,this.session=e.session,this.dialect=e.dialect,this.withList=e.withList,this.distinct=e.distinct}from(e){const s=!!this.fields;let r;return this.fields?r=this.fields:d(e,Y)?r=Object.fromEntries(Object.keys(e._.selectedFields).map(n=>[n,e[n]])):d(e,xr)?r=e[M].selectedFields:d(e,m)?r={}:r=Xo(e),new Cr({table:e,fields:r,isPartialSelect:s,session:this.session,dialect:this.dialect,withList:this.withList,distinct:this.distinct})}}class ya extends ma{static[f]="SQLiteSelectQueryBuilder";_;config;joinsNotNullableMap;tableName;isPartialSelect;session;dialect;constructor({table:e,fields:s,isPartialSelect:r,session:n,dialect:i,withList:o,distinct:a}){super(),this.config={withList:o,table:e,fields:{...s},distinct:a,setOperators:[]},this.isPartialSelect=r,this.session=n,this.dialect=i,this._={selectedFields:s},this.tableName=ys(e),this.joinsNotNullableMap=typeof this.tableName=="string"?{[this.tableName]:!0}:{}}createJoin(e){return(s,r)=>{const n=this.tableName,i=ys(s);if(typeof i=="string"&&this.config.joins?.some(o=>o.alias===i))throw new Error(`Alias "${i}" is already used in this query`);if(!this.isPartialSelect&&(Object.keys(this.joinsNotNullableMap).length===1&&typeof n=="string"&&(this.config.fields={[n]:this.config.fields}),typeof i=="string"&&!d(s,m))){const o=d(s,Y)?s._.selectedFields:d(s,xe)?s[M].selectedFields:s[y.Symbol.Columns];this.config.fields[i]=o}if(typeof r=="function"&&(r=r(new Proxy(this.config.fields,new J({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))),this.config.joins||(this.config.joins=[]),this.config.joins.push({on:r,table:s,joinType:e,alias:i}),typeof i=="string")switch(e){case"left":{this.joinsNotNullableMap[i]=!1;break}case"right":{this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([o])=>[o,!1])),this.joinsNotNullableMap[i]=!0;break}case"inner":{this.joinsNotNullableMap[i]=!0;break}case"full":{this.joinsNotNullableMap=Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([o])=>[o,!1])),this.joinsNotNullableMap[i]=!1;break}}return this}}leftJoin=this.createJoin("left");rightJoin=this.createJoin("right");innerJoin=this.createJoin("inner");fullJoin=this.createJoin("full");createSetOperator(e,s){return r=>{const n=typeof r=="function"?r(wa()):r;if(!Rr(this.getSelectedFields(),n.getSelectedFields()))throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return this.config.setOperators.push({type:e,isAll:s,rightSelect:n}),this}}union=this.createSetOperator("union",!1);unionAll=this.createSetOperator("union",!0);intersect=this.createSetOperator("intersect",!1);except=this.createSetOperator("except",!1);addSetOperators(e){return this.config.setOperators.push(...e),this}where(e){return typeof e=="function"&&(e=e(new Proxy(this.config.fields,new J({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))),this.config.where=e,this}having(e){return typeof e=="function"&&(e=e(new Proxy(this.config.fields,new J({sqlAliasedBehavior:"sql",sqlBehavior:"sql"})))),this.config.having=e,this}groupBy(...e){if(typeof e[0]=="function"){const s=e[0](new Proxy(this.config.fields,new J({sqlAliasedBehavior:"alias",sqlBehavior:"sql"})));this.config.groupBy=Array.isArray(s)?s:[s]}else this.config.groupBy=e;return this}orderBy(...e){if(typeof e[0]=="function"){const s=e[0](new Proxy(this.config.fields,new J({sqlAliasedBehavior:"alias",sqlBehavior:"sql"}))),r=Array.isArray(s)?s:[s];this.config.setOperators.length>0?this.config.setOperators.at(-1).orderBy=r:this.config.orderBy=r}else{const s=e;this.config.setOperators.length>0?this.config.setOperators.at(-1).orderBy=s:this.config.orderBy=s}return this}limit(e){return this.config.setOperators.length>0?this.config.setOperators.at(-1).limit=e:this.config.limit=e,this}offset(e){return this.config.setOperators.length>0?this.config.setOperators.at(-1).offset=e:this.config.offset=e,this}getSQL(){return this.dialect.buildSelectQuery(this.config)}toSQL(){const{typings:e,...s}=this.dialect.sqlToQuery(this.getSQL());return s}as(e){return new Proxy(new Y(this.getSQL(),this.config.fields,e),new J({alias:e,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}getSelectedFields(){return new Proxy(this.config.fields,new J({alias:this.tableName,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}$dynamic(){return this}}class Cr extends ya{static[f]="SQLiteSelect";_prepare(e=!0){if(!this.session)throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");const s=ue(this.config.fields),r=this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),s,"all",!0);return r.joinsNotNullableMap=this.joinsNotNullableMap,r}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(){return this.all()}}Go(Cr,[he]);function at(t,e){return(s,r,...n)=>{const i=[r,...n].map(o=>({type:t,isAll:e,rightSelect:o}));for(const o of i)if(!Rr(s.getSelectedFields(),o.rightSelect.getSelectedFields()))throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");return s.addSetOperators(i)}}const wa=()=>({union:ba,unionAll:ga,intersect:Sa,except:_a}),ba=at("union",!1),ga=at("union",!0),Sa=at("intersect",!1),_a=at("except",!1);class qa{static[f]="SQLiteQueryBuilder";dialect;$with(e){const s=this;return{as(r){return typeof r=="function"&&(r=r(s)),new Proxy(new yr(r.getSQL(),r.getSelectedFields(),e,!0),new J({alias:e,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}}}with(...e){const s=this;function r(i){return new te({fields:i??void 0,session:void 0,dialect:s.getDialect(),withList:e})}function n(i){return new te({fields:i??void 0,session:void 0,dialect:s.getDialect(),withList:e,distinct:!0})}return{select:r,selectDistinct:n}}select(e){return new te({fields:e??void 0,session:void 0,dialect:this.getDialect()})}selectDistinct(e){return new te({fields:e??void 0,session:void 0,dialect:this.getDialect(),distinct:!0})}getDialect(){return this.dialect||(this.dialect=new fa),this.dialect}}class gs{constructor(e,s,r,n){this.table=e,this.session=s,this.dialect=r,this.withList=n}static[f]="SQLiteUpdateBuilder";set(e){return new Ra(this.table,Tr(this.table,e),this.session,this.dialect,this.withList)}}class Ra extends he{constructor(e,s,r,n,i){super(),this.session=r,this.dialect=n,this.config={set:s,table:e,withList:i}}static[f]="SQLiteUpdate";config;where(e){return this.config.where=e,this}returning(e=this.config.table[K.Symbol.Columns]){return this.config.returning=ue(e),this}getSQL(){return this.dialect.buildUpdateQuery(this.config)}toSQL(){const{typings:e,...s}=this.dialect.sqlToQuery(this.getSQL());return s}_prepare(e=!0){return this.session[e?"prepareOneTimeQuery":"prepareQuery"](this.dialect.sqlToQuery(this.getSQL()),this.config.returning,this.config.returning?"all":"run",!0)}prepare(){return this._prepare(!1)}run=e=>this._prepare().run(e);all=e=>this._prepare().all(e);get=e=>this._prepare().get(e);values=e=>this._prepare().values(e);async execute(){return this.config.returning?this.all():this.run()}$dynamic(){return this}}class Ta{constructor(e,s,r,n,i,o,a,l){this.mode=e,this.fullSchema=s,this.schema=r,this.tableNamesMap=n,this.table=i,this.tableConfig=o,this.dialect=a,this.session=l}static[f]="SQLiteAsyncRelationalQueryBuilder";findMany(e){return this.mode==="sync"?new Ss(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e||{},"many"):new Et(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e||{},"many")}findFirst(e){return this.mode==="sync"?new Ss(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e?{...e,limit:1}:{limit:1},"first"):new Et(this.fullSchema,this.schema,this.tableNamesMap,this.table,this.tableConfig,this.dialect,this.session,e?{...e,limit:1}:{limit:1},"first")}}class Et extends he{constructor(e,s,r,n,i,o,a,l,u){super(),this.fullSchema=e,this.schema=s,this.tableNamesMap=r,this.table=n,this.tableConfig=i,this.dialect=o,this.session=a,this.config=l,this.mode=u}static[f]="SQLiteAsyncRelationalQuery";mode;getSQL(){return this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}).sql}_prepare(e=!1){const{query:s,builtQuery:r}=this._toSQL();return this.session[e?"prepareOneTimeQuery":"prepareQuery"](r,void 0,this.mode==="first"?"get":"all",!0,(n,i)=>{const o=n.map(a=>Nt(this.schema,this.tableConfig,a,s.selection,i));return this.mode==="first"?o[0]:o})}prepare(){return this._prepare(!1)}_toSQL(){const e=this.dialect.buildRelationalQuery({fullSchema:this.fullSchema,schema:this.schema,tableNamesMap:this.tableNamesMap,table:this.table,tableConfig:this.tableConfig,queryConfig:this.config,tableAlias:this.tableConfig.tsName}),s=this.dialect.sqlToQuery(e.sql);return{query:e,builtQuery:s}}toSQL(){return this._toSQL().builtQuery}executeRaw(){return this.mode==="first"?this._prepare(!1).get():this._prepare(!1).all()}async execute(){return this.executeRaw()}}class Ss extends Et{static[f]="SQLiteSyncRelationalQuery";sync(){return this.executeRaw()}}class je extends he{constructor(e,s,r,n,i){super(),this.execute=e,this.getSQL=s,this.dialect=n,this.mapBatchResult=i,this.config={action:r}}static[f]="SQLiteRaw";config;getQuery(){return{...this.dialect.sqlToQuery(this.getSQL()),method:this.config.action}}mapResult(e,s){return s?this.mapBatchResult(e):e}_prepare(){return this}isResponseInArrayMode(){return!1}}class Er{constructor(e,s,r,n){this.resultKind=e,this.dialect=s,this.session=r,this._=n?{schema:n.schema,fullSchema:n.fullSchema,tableNamesMap:n.tableNamesMap}:{schema:void 0,fullSchema:{},tableNamesMap:{}},this.query={};const i=this.query;if(this._.schema)for(const[o,a]of Object.entries(this._.schema))i[o]=new Ta(e,n.fullSchema,this._.schema,this._.tableNamesMap,n.fullSchema[o],a,s,r)}static[f]="BaseSQLiteDatabase";query;$with(e){return{as(s){return typeof s=="function"&&(s=s(new qa)),new Proxy(new yr(s.getSQL(),s.getSelectedFields(),e,!0),new J({alias:e,sqlAliasedBehavior:"alias",sqlBehavior:"error"}))}}}with(...e){const s=this;function r(l){return new te({fields:l??void 0,session:s.session,dialect:s.dialect,withList:e})}function n(l){return new te({fields:l??void 0,session:s.session,dialect:s.dialect,withList:e,distinct:!0})}function i(l){return new gs(l,s.session,s.dialect,e)}function o(l){return new bs(l,s.session,s.dialect,e)}function a(l){return new ws(l,s.session,s.dialect,e)}return{select:r,selectDistinct:n,update:i,insert:o,delete:a}}select(e){return new te({fields:e??void 0,session:this.session,dialect:this.dialect})}selectDistinct(e){return new te({fields:e??void 0,session:this.session,dialect:this.dialect,distinct:!0})}update(e){return new gs(e,this.session,this.dialect)}insert(e){return new bs(e,this.session,this.dialect)}delete(e){return new ws(e,this.session,this.dialect)}run(e){const s=e.getSQL();return this.resultKind==="async"?new je(async()=>this.session.run(s),()=>s,"run",this.dialect,this.session.extractRawRunValueFromBatchResult.bind(this.session)):this.session.run(s)}all(e){const s=e.getSQL();return this.resultKind==="async"?new je(async()=>this.session.all(s),()=>s,"all",this.dialect,this.session.extractRawAllValueFromBatchResult.bind(this.session)):this.session.all(s)}get(e){const s=e.getSQL();return this.resultKind==="async"?new je(async()=>this.session.get(s),()=>s,"get",this.dialect,this.session.extractRawGetValueFromBatchResult.bind(this.session)):this.session.get(s)}values(e){const s=e.getSQL();return this.resultKind==="async"?new je(async()=>this.session.values(s),()=>s,"values",this.dialect,this.session.extractRawValuesValueFromBatchResult.bind(this.session)):this.session.values(s)}transaction(e,s){return this.session.transaction(e,s)}}class xa extends he{constructor(e){super(),this.resultCb=e}static[f]="ExecuteResultSync";async execute(){return this.resultCb()}sync(){return this.resultCb()}}class Na{constructor(e,s,r){this.mode=e,this.executeMethod=s,this.query=r}static[f]="PreparedQuery";joinsNotNullableMap;getQuery(){return this.query}mapRunResult(e,s){return e}mapAllResult(e,s){throw new Error("Not implemented")}mapGetResult(e,s){throw new Error("Not implemented")}execute(e){return this.mode==="async"?this[this.executeMethod](e):new xa(()=>this[this.executeMethod](e))}mapResult(e,s){switch(this.executeMethod){case"run":return this.mapRunResult(e,s);case"all":return this.mapAllResult(e,s);case"get":return this.mapGetResult(e,s)}}}class Ca{constructor(e){this.dialect=e}static[f]="SQLiteSession";prepareOneTimeQuery(e,s,r,n){return this.prepareQuery(e,s,r,n)}run(e){const s=this.dialect.sqlToQuery(e);try{return this.prepareOneTimeQuery(s,void 0,"run",!1).run()}catch(r){throw new Vt({cause:r,message:`Failed to run the query '${s.sql}'`})}}extractRawRunValueFromBatchResult(e){return e}all(e){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(e),void 0,"run",!1).all()}extractRawAllValueFromBatchResult(e){throw new Error("Not implemented")}get(e){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(e),void 0,"run",!1).get()}extractRawGetValueFromBatchResult(e){throw new Error("Not implemented")}values(e){return this.prepareOneTimeQuery(this.dialect.sqlToQuery(e),void 0,"run",!1).values()}extractRawValuesValueFromBatchResult(e){throw new Error("Not implemented")}}class Ea extends Er{constructor(e,s,r,n,i=0){super(e,s,r,n),this.schema=n,this.nestedIndex=i}static[f]="SQLiteTransaction";rollback(){throw new Zo}}class Jt extends Ca{constructor(e,s,r,n,i){super(s),this.client=e,this.schema=r,this.options=n,this.tx=i,this.logger=n.logger??new co}static[f]="LibSQLSession";logger;prepareQuery(e,s,r,n,i){return new Ia(this.client,e,this.logger,s,this.tx,r,n,i)}async batch(e){const s=[],r=[];for(const i of e){const o=i._prepare(),a=o.getQuery();s.push(o),r.push({sql:a.sql,args:a.params})}return(await this.client.batch(r)).map((i,o)=>s[o].mapResult(i,!0))}async transaction(e,s){const r=await this.client.transaction(),n=new Jt(this.client,this.dialect,this.schema,this.options,r),i=new Ht("async",this.dialect,n,this.schema);try{const o=await e(i);return await r.commit(),o}catch(o){throw await r.rollback(),o}}extractRawAllValueFromBatchResult(e){return e.rows}extractRawGetValueFromBatchResult(e){return e.rows[0]}extractRawValuesValueFromBatchResult(e){return e.rows}}class Ht extends Ea{static[f]="LibSQLTransaction";async transaction(e){const s=`sp${this.nestedIndex}`,r=new Ht("async",this.dialect,this.session,this.schema,this.nestedIndex+1);await this.session.run(c.raw(`savepoint ${s}`));try{const n=await e(r);return await this.session.run(c.raw(`release savepoint ${s}`)),n}catch(n){throw await this.session.run(c.raw(`rollback to savepoint ${s}`)),n}}}class Ia extends Na{constructor(e,s,r,n,i,o,a,l){super("async",o,s),this.client=e,this.logger=r,this.fields=n,this.tx=i,this._isResponseInArrayMode=a,this.customResultMapper=l,this.customResultMapper=l,this.fields=n}static[f]="LibSQLPreparedQuery";run(e){const s=Fe(this.query.params,e??{});this.logger.logQuery(this.query.sql,s);const r={sql:this.query.sql,args:s};return this.tx?this.tx.execute(r):this.client.execute(r)}async all(e){const{fields:s,logger:r,query:n,tx:i,client:o,customResultMapper:a}=this;if(!s&&!a){const u=Fe(n.params,e??{});r.logQuery(n.sql,u);const h={sql:n.sql,args:u};return(i?i.execute(h):o.execute(h)).then(({rows:p})=>this.mapAllResult(p))}const l=await this.values(e);return this.mapAllResult(l)}mapAllResult(e,s){return s&&(e=e.rows),!this.fields&&!this.customResultMapper?e.map(r=>_s(r)):this.customResultMapper?this.customResultMapper(e,Ve):e.map(r=>ms(this.fields,Array.prototype.slice.call(r).map(n=>Ve(n)),this.joinsNotNullableMap))}async get(e){const{fields:s,logger:r,query:n,tx:i,client:o,customResultMapper:a}=this;if(!s&&!a){const u=Fe(n.params,e??{});r.logQuery(n.sql,u);const h={sql:n.sql,args:u};return(i?i.execute(h):o.execute(h)).then(({rows:p})=>this.mapGetResult(p))}const l=await this.values(e);return this.mapGetResult(l)}mapGetResult(e,s){s&&(e=e.rows);const r=e[0];if(!this.fields&&!this.customResultMapper)return _s(r);if(r)return this.customResultMapper?this.customResultMapper(e,Ve):ms(this.fields,Array.prototype.slice.call(r).map(n=>Ve(n)),this.joinsNotNullableMap)}values(e){const s=Fe(this.query.params,e??{});this.logger.logQuery(this.query.sql,s);const r={sql:this.query.sql,args:s};return(this.tx?this.tx.execute(r):this.client.execute(r)).then(({rows:n})=>n)}isResponseInArrayMode(){return this._isResponseInArrayMode}}function _s(t){return Object.keys(t).reduce((e,s)=>(Object.prototype.propertyIsEnumerable.call(t,s)&&(e[s]=t[s]),e),{})}function Ve(t){if(typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer){if(typeof Buffer<"u")return t instanceof Buffer?t:Buffer.from(t);if(typeof TextDecoder<"u")return new TextDecoder().decode(t);throw new Error("TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.")}return t}class La extends Er{static[f]="LibSQLDatabase";async batch(e){return this.session.batch(e)}}function Aa(t,e={}){const s=new pa;let r;e.logger===!0?r=new uo:e.logger!==!1&&(r=e.logger);let n;if(e.schema){const o=Vo(e.schema,Jo);n={fullSchema:e.schema,schema:o.tables,tableNamesMap:o.tableNamesMap}}const i=new Jt(t,s,n,{logger:r},void 0);return new La("async",s,i,n)}const qs={tursoConnectionUrl:{BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1,SITE:void 0,ASSETS_PREFIX:void 0}.PUBLIC_TURSO_CONNECTION_URL??"",tursoAuthToken:{BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1,SITE:void 0,ASSETS_PREFIX:void 0}.PUBLIC_TURSO_AUTH_TOKEN??""},Ie=oo({url:qs.tursoConnectionUrl,authToken:qs.tursoAuthToken}),ce=Aa(Ie),Ir=ot("employees",{id:j("id").primaryKey(),firstName:k("first_name").notNull(),lastName:k("last_name").notNull(),email:k("email").notNull(),dni:k("dni").notNull(),entryTime:k("entry_time").notNull(),exitTime:k("exit_time").notNull(),hoursWorked:j("hours_worked").notNull(),xLite:k("x_lite").notNull()}),It=ot("break_schedules",{id:j("id").primaryKey(),employeeId:j("employee_id").notNull(),day:k("day").notNull(),startTime:k("start_time").notNull(),endTime:k("end_time").notNull(),week:j("week").notNull(),month:j("month").notNull(),year:j("year").notNull()}),Lr=ot("users",{id:j("id").primaryKey(),name:k("name").notNull(),responses:j("responses").notNull().default(0),nps:j("nps").notNull().default(0),csat:j("csat").notNull().default(0),rd:j("rd").notNull().default(0)});ot("novedades",{id:j("id").primaryKey(),url:k("url").notNull(),title:k("title").notNull(),publishDate:k("publish_date").notNull()});async function Gt(){await Ie.execute(`
    CREATE TABLE IF NOT EXISTS employees (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      first_name TEXT NOT NULL,
      last_name TEXT NOT NULL,
      email TEXT NOT NULL,
      dni TEXT NOT NULL,
      entry_time TEXT NOT NULL,
      exit_time TEXT NOT NULL,
      hours_worked INTEGER NOT NULL,
      x_lite TEXT NOT NULL
    )
  `),await Ie.execute(`
    CREATE TABLE IF NOT EXISTS break_schedules (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      employee_id INTEGER NOT NULL,
      day TEXT NOT NULL,
      start_time TEXT NOT NULL,
      end_time TEXT NOT NULL,
      week INTEGER NOT NULL,
      month INTEGER NOT NULL,
      year INTEGER NOT NULL
    )
  `),await Ie.execute(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      responses INTEGER NOT NULL DEFAULT 0,
      nps INTEGER NOT NULL DEFAULT 0,
      csat INTEGER NOT NULL DEFAULT 0,
      rd INTEGER NOT NULL DEFAULT 0
    )
  `),await Ie.execute(`
    CREATE TABLE IF NOT EXISTS novedades (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      url TEXT NOT NULL,
      title TEXT NOT NULL,
      publish_date TEXT NOT NULL
    )
  `)}async function Ua(){try{return await Gt(),await ce.select().from(Ir).all()}catch(t){throw console.error("Error al obtener empleados:",t),new Error(`No se pudieron obtener los empleados: ${t instanceof Error?t.message:String(t)}`)}}async function Da(t,e){try{await ce.update(Ir).set({xLite:e}).where(c`id = ${t}`).run()}catch(s){throw console.error("Error al actualizar X LITE del empleado:",s),new Error(`No se pudo actualizar X LITE del empleado: ${s instanceof Error?s.message:String(s)}`)}}async function ka(t,e,s){try{return await Gt(),await ce.select().from(It).where(c`employee_id = ${t} AND month = ${e} AND year = ${s}`).all()}catch(r){throw console.error("Error al obtener horarios de break:",r),new Error(`No se pudieron obtener los horarios de break: ${r instanceof Error?r.message:String(r)}`)}}async function Ma(t){try{console.log("Intentando actualizar horario de break:",t),(await ce.update(It).set({startTime:t.startTime,endTime:t.endTime}).where(c`
        employee_id = ${t.employeeId} AND
        day = ${t.day} AND
        week = ${t.week} AND
        month = ${t.month} AND
        year = ${t.year}
      `).run()).rowsAffected===0&&await ce.insert(It).values(t).run(),console.log("Horario de break actualizado o insertado con xito")}catch(e){throw console.error("Error detallado al actualizar horario de break:",e),new Error(`No se pudo actualizar el horario de break: ${e instanceof Error?e.message:String(e)}`)}}async function Fa(){try{return await Gt(),await ce.select().from(Lr).all()}catch(t){throw console.error("Error al obtener usuarios:",t),new Error(`No se pudieron obtener los usuarios: ${t instanceof Error?t.message:String(t)}`)}}async function ja(t){try{await ce.update(Lr).set(t).where(c`id = ${t.id}`).run()}catch(e){throw console.error("Error al actualizar usuario:",e),new Error(`No se pudo actualizar el usuario: ${e instanceof Error?e.message:String(e)}`)}}export{ka as a,Ma as b,Fa as c,ja as d,Ua as g,Da as u};
